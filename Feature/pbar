#!/bin/sh
# Astral v0.5.1 - minimal POSIX package manager for Astaraxia
# Features: Source-only, Auto-recipe fetch, Version locking, Build isolation,
#           added sum, fixed recursive recipe lookup

# Set strict execution environment
set -eu

# Global state variables
INSTALL_ROOT="/"    # Installation target directory
FORCE_INSTALL=0     # Force flag (0=off, 1=on)

# Directory Layout
RECIPES_DIR=${RECIPES_DIR:-/usr/src/astral/recipes}
CACHE_SRC=${CACHE_SRC:-/var/cache/astral/src}
CACHE_BIN=${CACHE_BIN:-/var/cache/astral/bin}
DB_DIR=${DB_DIR:-/var/lib/astral/db}
REPO_URL=${REPO_URL:-https://izumi-sonoka.github.io/Astral-Repo/}
RECIPE_RAW_URL=${RECIPE_RAW_URL:-https://raw.githubusercontent.com/Izumi-Sonoka/Astral-Repo/main}
INDEX_FILE="$DB_DIR/index"
LOG_DIR=${LOG_DIR:-/var/log/astral}

# --- SELF-UPDATE URLs ---
SELF_UPDATE_URL_MAIN=${SELF_UPDATE_URL_MAIN:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/main/astral}
SELF_UPDATE_URL_CUTTING_EDGE=${SELF_UPDATE_URL_CUTTING_EDGE:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/Testing/astra}
SELF_UPDATE_URL_BLEEDING_EDGE=${SELF_UPDATE_URL_BLEEDING_EDGE:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/Testing/astral}
SELF_UPDATE_PATH=/usr/bin/astral
TMPDIR=${TMPDIR:-/tmp}

mkdir -p "$RECIPES_DIR" "$CACHE_SRC" "$CACHE_BIN" "$DB_DIR" "$LOG_DIR" "$TMPDIR"

err() { printf 'ERROR: %s\n' "$*" >&2; exit 1; }
info() { printf '%s\n' "$*"; }

version="0.5.1"

astral_version() {
cat <<EOF
Astral version $version
EOF
    exit 0
}

usage() {
    cat <<USAGE
$version
Usage: astral [global_opts] <command> [pkg...]
Global Options:
  -f, --force           Do force installation/build/removal.
  --dir <DIR>           Specify root directory for installing packages (defaults to /).

Commands:
  -s, --sync <pkg>      Download recipe (if missing), check deps, and install/upgrade.
  -comp, --compile <pkg> Build from recipe and install (force build).
  -u, --update          Updates the remote package index (for search).
  --search <pkg>        Searches for package in local recipes and remote index.
  -R, --Remove <pkg>    Remove package (leave deps).
  -r, --RemoveDep <pkg> Remove package and attempt to remove orphan deps.
  -Cc, --Clean-Cache    Remove recipes for packages that are NOT currently installed.
  -U, --self-update [BR] Update the astral script itself from GitHub. BR can be 'main' (default) or 'bleeding-edge'.
  -ins, --inspect <pkg> Show recipe files, including package info and build script head.
  -I, --info <pkg>    Show detailed information about an installed or remote package.
  -ua, --upgrade-all  Perform system upgrade (syncs all installed packages).
  -ll, --list-installed List installed packages.
  -V, --version       Show Astral version.
USAGE
}

# --- CORE UTILITY FUNCTIONS ---

is_pkg_installed() {
    pkg="$1"
    # Need to check if the exact path or leaf name is installed
    [ -d "$DB_DIR/$pkg" ] || [ -n "$(find "$DB_DIR" -type d -name "$pkg" -maxdepth 2 2>/dev/null)" ]
}

# NEW HELPER: Resolves the simple package name (e.g., 'nano') or the full path (e.g., 'app-editors/nano') 
# to the canonical path relative to $DB_DIR (e.g., 'app-editors/nano').
resolve_installed_path() {
    local requested_pkg="$1"
    
    # 1. Check if the input is already a full, installed path (e.g., app-editors/nano)
    if [ -d "$DB_DIR/$requested_pkg" ]; then
        echo "$requested_pkg"
        return 0
    fi
    
    # 2. Check if the input is just the leaf name (e.g., nano)
    local found_path
    # Search for a directory with the exact name, limiting search depth
    found_path=$(find "$DB_DIR" -type d -name "$requested_pkg" -maxdepth 2 2>/dev/null | head -n 1)
    
    if [ -n "$found_path" ]; then
        # Return path relative to $DB_DIR
        echo "$found_path" | sed "s|^${DB_DIR}/||"
        return 0
    fi
    
    return 1
}

# helper: find recipe path - NOW SEARCHES SUBDIRECTORIES
recipe_path() {
    local pkg="$1"
    local found_path=""
    
    # 1. Search directly (e.g., $RECIPES_DIR/nano)
    if [ -d "$RECIPES_DIR/$pkg" ]; then
        echo "$RECIPES_DIR/$pkg"
        return 0
    fi
    
    # 2. Search in subdirectories (e.g., $RECIPES_DIR/app-editors/nano)
    # Find package directory matching the name, restricting depth to 2 (category/pkg)
    # Using find is the most reliable POSIX way to search recursively.
    found_path=$(find "$RECIPES_DIR" -type d -name "$pkg" -maxdepth 2 2>/dev/null | head -n 1)
    
    if [ -n "$found_path" ] && [ -d "$found_path" ]; then
        echo "$found_path"
        return 0
    fi
    
    # 3. Check for single file (ignored in favor of directory recipes)
    return 1
}

# Get installed version (returns "none" if not installed)
get_installed_ver() {
    local requested_pkg="$1"
    local pkg_path
    pkg_path=$(resolve_installed_path "$requested_pkg") || { echo "none"; return 0; }

    if [ -f "$DB_DIR/$pkg_path/version" ]; then
        cat "$DB_DIR/$pkg_path/version"
    else
        echo "none"
    fi
}

create_meta() {
    pkg="$1"; ver="$2"; arch="$3"; dest="$4"
    cat > "$dest/.astral-meta" <<M
name=$pkg
version=$ver
arch=$arch
M
}

# Extracts dependency names from the depends file, filtering comments and empty lines.
get_pkg_deps() {
    local pkg="$1"
    local depfile
    
    # First, try to resolve the installed path for dependencies
    local pkg_path
    pkg_path=$(resolve_installed_path "$pkg") 2>/dev/null || pkg_path="$pkg"

    # Check the installed DB (for info/removal)
    depfile="$DB_DIR/$pkg_path/depends"
    
    # If not in DB, check the recipe path
    if [ ! -f "$depfile" ]; then
        local rpath
        rpath=$(recipe_path "$pkg") 2>/dev/null || rpath=""
        [ -n "$rpath" ] && depfile="$rpath/depends"
    fi
    
    [ -f "$depfile" ] || return 0
    
    # Use POSIX ERE [[:space:]] to filter comments and empty lines, preserving newlines.
    grep -v '^[[:space:]]*#' "$depfile" | grep -E -v '^[[:space:]]*$'
}

# Checks if a package is required by any other installed package.
is_pkg_required() {
    local target_pkg_path="$1"
    local target_pkg=$(basename "$target_pkg_path")
    
    for other_pkg_dir in "$DB_DIR"/*/* "$DB_DIR"/*; do
        [ -d "$other_pkg_dir" ] || continue
        local other_pkg_path=$(echo "$other_pkg_dir" | sed "s|^${DB_DIR}/||")
        [ "$other_pkg_path" = "$target_pkg_path" ] && continue
        
        # Check if the other package's installed dependency list contains target_pkg_path or target_pkg
        local other_deps=$(get_pkg_deps "$other_pkg_path")
        if echo "$other_deps" | grep -qE "^${target_pkg_path}$|^${target_pkg}$"; then
            return 0 # Required
        fi
    done
    return 1 # Not required
}

# --- NETWORKING FUNCTIONS ---

# Fetch recipe files from remote
fetch_remote_recipe() {
    local pkg="$1"
    local local_dir="$RECIPES_DIR/$pkg" # NOTE: We assume $pkg is the name, but remote URL needs category

    info "Attempting to fetch or refresh recipe for '$pkg' from remote..."
    
    # If the recipe is found locally, we can infer the category for remote fetch.
    local category_pkg=""
    local recipe_dir_name="$pkg"
    
    local existing_rpath
    existing_rpath=$(recipe_path "$pkg") 2>/dev/null || existing_rpath=""

    if [ -n "$existing_rpath" ]; then
        # Example: /usr/src/astral/recipes/app-editors/nano -> app-editors/nano
        category_pkg=$(echo "$existing_rpath" | sed "s|^${RECIPES_DIR}/||")
        recipe_dir_name=$(basename "$existing_rpath")
    else
        # If not found, we cannot infer the category. We must guess based on typical names.
        # A full system would require a remote index lookup here to get the category.
        category_pkg="$pkg"
    fi
    
    local remote_base="${RECIPE_RAW_URL%/}/recipes/$category_pkg"

    # Create the local directory structure (e.g., $RECIPES_DIR/app-editors/nano)
    # We must use the *full* inferred path if possible, or fall back to simple $pkg name.
    if [ -n "$category_pkg" ] && [ "$category_pkg" != "$pkg" ]; then
        local_dir="$RECIPES_DIR/$category_pkg"
        mkdir -p "$local_dir"
    else
        local_dir="$RECIPES_DIR/$pkg"
        mkdir -p "$local_dir"
    fi

    local required_files="version build sources"
    local optional_files="depends package post_install post_remove checksums conflicts info"
    
    for file in $required_files $optional_files; do
        local url="$remote_base/$file"
        local dest="$local_dir/$file"
        
        # Download silently (-s), fail on 404 (-f).
        if curl -fsSL "$url" -o "$dest" 2>/dev/null; then
            :
        else
            # Check against mandatory files
            if echo "$required_files" | grep -q "$file"; then
                err "Failed to fetch mandatory file '$file' for package '$pkg' from $url"
                rm -rf "$local_dir"
                return 1
            fi
            # If optional file fails, just remove the old local copy
            rm -f "$dest"
        fi
    done
    
    # Make scripts executable
    chmod +x "$local_dir/build" 2>/dev/null || true
    chmod +x "$local_dir/package" 2>/dev/null || true
    chmod +x "$local_dir/post_install" 2>/dev/null || true
    chmod +x "$local_dir/post_remove" 2>/dev/null || true
    
    info "Recipe for '$pkg' refreshed successfully at $local_dir."
}

# Helper function to download source archives
download_sources() {
    local rpath="$1"
    local buildtmp="$2"
    local sources_file="$rpath/sources"
    [ -f "$sources_file" ] || return 0 

    info "Downloading source archives..."

    local filtered_sources
    filtered_sources=$(grep -v '^[[:space:]]*#' "$sources_file" | grep -E -v '^[[:space:]]*$')

    echo "$filtered_sources" | while IFS= read -r url; do
        url=$(echo "$url" | tr -d '[:space:]')
        [ -z "$url" ] && continue
        
        local filename=$(basename "$url")
        local dest_file="$buildtmp/$filename"
        
        info "  -> Downloading $filename"

        if ! curl -fsSL "$url" -o "$dest_file"; then
            err "Failed to download source file from $url"
        fi
    done
}

# Verify checksums and extract archives
verify_checksums_and_extract() {
    local pkg="$1"
    local rpath="$2"
    local buildtmp="$3"
    
    local checksums_file="$rpath/checksums"
    [ -f "$checksums_file" ] || { info "No checksums provided for $pkg. Skipping integrity check."; return 0; }
    
    command -v sha256sum >/dev/null 2>&1 || err "sha256sum command not found. Cannot verify source integrity."

    info "Verifying source integrity using checksums..."
    
    while IFS= read -r line; do
        line=$(echo "$line" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
        [ -z "$line" ] && continue
        [ "${line:0:1}" = "#" ] && continue
        
        local expected_hash=$(echo "$line" | awk '{print $1}')
        local filename=$(echo "$line" | awk '{print $2}')

        if [ -z "$expected_hash" ] || [ -z "$filename" ]; then
            err "Checksum file format error for $pkg. Line: '$line'"
        fi

        local file_path="$buildtmp/$filename"

        if [ ! -f "$file_path" ]; then
            err "Checksum error: Source file '$filename' not found in build directory. Cannot verify."
        fi

        local actual_hash=$(sha256sum "$file_path" | awk '{print $1}')
        
        if [ "$actual_hash" != "$expected_hash" ]; then
            err "Checksum mismatch for $filename! Expected $expected_hash, got $actual_hash. Source may be corrupted or compromised. Aborting."
        else
            info "  -> Checksum verified for $filename."
        fi
    done < "$checksums_file"

    info "Checksums verified. Extracting sources..."
    local sources_file="$rpath/sources"
    
    while IFS= read -r url; do
        url=$(echo "$url" | grep -E -v '^[[:space:]]*#' | grep -E -v '^[[:space:]]*$')
        [ -z "$url" ] && continue
        
        local filename=$(basename "$url")
        local dest_file="$buildtmp/$filename"
        
        info "  -> Extracting $filename"
        
        case "$filename" in
            *.tar.gz|*.tgz) tar -xf "$dest_file" -C "$buildtmp" || err "Tar extract failed for $filename" ;;
            *.tar.bz2|*.tbz) tar -xf "$dest_file" -C "$buildtmp" || err "Bzip2 extract failed for $filename" ;;
            *.tar.xz|*.txz) tar -xf "$dest_file" -C "$buildtmp" || err "XZ extract failed for $filename" ;;
            *.zip) 
                command -v unzip >/dev/null 2>&1 || err "unzip command not found. Cannot extract ZIP archive."
                unzip -q "$dest_file" -d "$buildtmp" || err "Unzip failed for $filename" ;;
            *) 
                info "  -> Warning: Unknown archive type for $filename. Skipping extraction/treating as a file." 
                ;;
        esac
        
        rm -f "$dest_file"
    done < "$sources_file"
}

# --- COMMAND IMPLEMENTATION FUNCTIONS ---

sync_pkg_recursive() {
    local pkg="$1"
    
    # NEW FIX: Check if this is a host-provided dependency (like make, gcc).
    # If found in PATH, we treat the dependency as satisfied and skip recipe fetch/build.
    if check_host_dependency "$pkg"; then
        info "Dependency '$pkg' satisfied by host system. Skipping recipe fetch and build."
        return 0
    fi
    
    # 1. Ensure we have the recipe (Download/Refresh)
    fetch_remote_recipe "$pkg"

    local recipe_dir
    recipe_dir=$(recipe_path "$pkg") || err "Recipe for '$pkg' could not be found or downloaded."

    # 2. Handle Dependencies (Recursive)
    info "Checking dependencies for $pkg..."
    get_pkg_deps "$pkg" | while IFS= read -r dep_pkg; do
        dep_pkg=$(echo "$dep_pkg" | tr -d '[:space:]')
        [ -z "$dep_pkg" ] && continue
        
        sync_pkg_recursive "$dep_pkg"
    done

    # 3. Build/Install
    build_from_recipe "$pkg"
}

build_from_recipe() {
    local pkg="$1"
    local rpath
    rpath=$(recipe_path "$pkg") || err "recipe $pkg not found"
    
    # --- VERSION CHECK LOGIC ---
    local recipe_ver="unknown"
    [ -f "$rpath/version" ] && recipe_ver=$(cat "$rpath/version")
    
    local installed_ver=$(get_installed_ver "$pkg")
    
    if [ "$installed_ver" != "none" ]; then
        if [ "$installed_ver" = "$recipe_ver" ]; then
            if [ "$FORCE_INSTALL" -eq 0 ]; then
                info "Package '$pkg' is already installed at version $installed_ver. Up to date. Skipping build."
                return 0
            else
                info "Package '$pkg' is installed, but force-rebuilding/reinstalling due to -f."
            fi
        else
            info "Upgrading '$pkg' from $installed_ver to $recipe_ver..."
        fi
    else
        info "Installing '$pkg' version $recipe_ver..."
    fi
    # ---------------------------------------------------------------------

    local buildtmp="$TMPDIR/astral-build-$pkg-$$"
    mkdir -p "$buildtmp"

    if [ -d "$rpath" ]; then
        cp -a "$rpath"/* "$buildtmp"/ 2>/dev/null || true
    else
        err "Directory recipe structure not found for $pkg."
    fi
    cd "$buildtmp"

    trap "rm -rf '$buildtmp'" EXIT 

    # 1. Fetch source code
    download_sources "$rpath" "$buildtmp"
    
    # 2. Verify Checksums and Extract
    verify_checksums_and_extract "$pkg" "$rpath" "$buildtmp"

    if [ -f "./build" ]; then
        chmod +x ./build || true
        local PKGDIR="$buildtmp/pkg"
        mkdir -p "$PKGDIR"
        
        info "Starting isolated build for $pkg..."
        # Execution environment for build.sh
        ( DESTDIR="$PKGDIR" ./build ) || err "build failed for $pkg" 
        
        if [ -f "./package" ]; then
            info "Running package hook for $pkg..."
            # Execution environment for package.sh
            ( DESTDIR="$PKGDIR" PKGDIR="$PKGDIR" ./package ) || err "package() failed for $pkg"
        fi
        
        create_meta "$pkg" "$recipe_ver" "x86_64" "$PKGDIR"
        
        local new_files
        new_files=$(
            ( cd "$PKGDIR" && find . -mindepth 1 -print ) \
            | sed 's/^\.\///' \
            | grep -v '^\.astral-meta$' \
            || true
        )

        info "Installing $pkg files to root filesystem ($INSTALL_ROOT)..."
        tar -C "$PKGDIR" -cf - . | tar -C "$INSTALL_ROOT" -xf - || err "failed to extract package files"
        
        # Determine the database path based on the recipe path
        local db_path
        db_path=$(echo "$rpath" | sed "s|^${RECIPES_DIR}/||")
        local pkgdir="$DB_DIR/$db_path"
        
        mkdir -p "$pkgdir"
        printf '%s\n' "$recipe_ver" > "$pkgdir/version"
        printf '%s\n' "$new_files" > "$pkgdir/files"
        
        if [ -f "$buildtmp/depends" ]; then
            cp "$buildtmp/depends" "$pkgdir/depends"
        fi
        
        # --- POST-INSTALL HOOK ---
        if [ -f "$buildtmp/post_install" ]; then
            info "Running post_install hook for $pkg..."
            ( DESTDIR="$INSTALL_ROOT" PKGDIR="$PKGDIR" "$buildtmp/post_install" ) || info "Warning: post_install hook failed for $pkg. Continuing."
        fi
        
        info "Successfully installed $pkg ($recipe_ver) to $INSTALL_ROOT."
    else
        err "Recipe $pkg has no build script"
    fi
    
    trap - EXIT
    rm -rf "$buildtmp" 
}

update_repo() {
    info "Updating package database index..."
    local INDEX_URL="${REPO_URL}astral.index"
    if curl -fsSL "$INDEX_URL" -o "$INDEX_FILE"; then
        info "Database updated successfully."
    else
        err "Failed to download index file from "$INDEX_URL"."
        return 1
    fi
}

search_pkg() {
    local query="$1"
    info "Searching for package '$query'..."
    info "--- Local Recipes ($RECIPES_DIR) ---"
    local found_local=0
    
    # Use find to search all subdirectories
    find "$RECIPES_DIR" -type d -mindepth 1 -maxdepth 2 2>/dev/null | while IFS= read -r r; do
        # Extract the package name (the deepest directory name)
        local pkg_name=$(basename "$r")
        if echo "$pkg_name" | grep -iq "$query"; then
            local ver="unknown"
            [ -f "$r/version" ] && ver=$(cat "$r/version")
            printf "L: %-20s (v%s) [%s]\n" "$pkg_name" "$ver" "$(basename "$(dirname "$r")")"
            found_local=1
        fi
    done
    [ "$found_local" -eq 0 ] && info "No local recipes found."

    info "--- Remote Index ($INDEX_FILE) ---"
    [ -f "$INDEX_FILE" ] || { info "Remote index not found. Run 'astral -u' to update."; return 0; }
    local found_remote=0
    while IFS= read -r line; do
        local pkg_name=$(echo "$line" | awk '{print $1}')
        local pkg_ver=$(echo "$line" | awk '{print $2}')
        if echo "$pkg_name" | grep -iq "$query"; then
            printf "R: %-20s (v%s)\n" "$pkg_name" "$pkg_ver"
            found_remote=1
        fi
    done < "$INDEX_FILE"
    [ "$found_remote" -eq 0 ] && info "No remote packages found."
}

show_pkg_info() {
    local requested_pkg="$1"
    local pkg_path
    pkg_path=$(resolve_installed_path "$requested_pkg") 2>/dev/null || pkg_path="$requested_pkg"
    
    local rpath
    rpath=$(recipe_path "$requested_pkg") 2>/dev/null || rpath=""
    local recipe_exists=0
    [ -n "$rpath" ] && recipe_exists=1
    
    info "--- Package Information: $pkg_path ---"
    
    # Installed Info
    local installed_ver=$(get_installed_ver "$requested_pkg")
    printf "Installed Version: %s\n" "$installed_ver"
    if [ "$installed_ver" != "none" ]; then
        local pkgdir="$DB_DIR/$pkg_path"
        local installed_date="N/A"
        [ -f "$pkgdir/files" ] && installed_date=$(stat -c "%y" "$pkgdir/files" 2>/dev/null || echo "N/A")
        printf "Installed Path:    %s\n" "$pkgdir"
        printf "Installation Date: %s\n" "$installed_date"
        printf "Installed Files:   %s files\n" "$(wc -l < "$pkgdir/files" 2>/dev/null || echo 0)"
        
        local installed_deps_list="None"
        local installed_deps_count=0
        local installed_deps=$(get_pkg_deps "$pkg_path")
        if [ -n "$installed_deps" ]; then
             installed_deps_list=$(echo "$installed_deps" | tr '\n' ' ')
             installed_deps_count=$(echo "$installed_deps" | wc -l)
        fi
        printf "Dependencies (%s): %s\n" "$installed_deps_count" "$installed_deps_list"
    fi
    
    # Recipe Info
    if [ "$recipe_exists" -eq 1 ]; then
        local recipe_ver=$(cat "$rpath/version" 2>/dev/null || echo "unknown")
        printf "\nRecipe Found:      Yes\n"
        printf "Recipe Version:    %s\n" "$recipe_ver"
        printf "Recipe Path:       %s\n" "$rpath"
        
        local recipe_deps_list="None"
        local recipe_deps_count=0
        local recipe_deps=$(get_pkg_deps "$requested_pkg")
        
        if [ -n "$recipe_deps" ]; then
            recipe_deps_list=$(echo "$recipe_deps" | tr '\n' ' ')
            recipe_deps_count=$(echo "$recipe_deps" | wc -l)
        fi
        printf "Recipe Deps (%s):   %s\n" "$recipe_deps_count" "$recipe_deps_list"
        
        local conflicts_list="None"
        local conflicts_count=0

        if [ -f "$rpath/conflicts" ]; then
            local filtered_conflicts=$(grep -v '^[[:space:]]*#' "$rpath/conflicts" | grep -E -v '^[[:space:]]*$')
            conflicts_list=$(echo "$filtered_conflicts" | tr '\n' ' ')
            conflicts_count=$(echo "$filtered_conflicts" | wc -l)
        fi
        printf "Conflicts (%s):     %s\n" "$conflicts_count" "$conflicts_list"
        
        printf "Build Script:      %s\n" "$( [ -f "$rpath/build" ] && echo "Yes" || echo "No" )"
        printf "Package Script:    %s\n" "$( [ -f "$rpath/package" ] && echo "Yes" || echo "No" )"
        printf "Checksums:         %s\n" "$( [ -f "$rpath/checksums" ] && echo "Yes" || echo "No" )"
    else
        printf "\nRecipe Found:      No (Run 'astral -s %s' to fetch)\n" "$requested_pkg"
    fi
}

upgrade_all() {
    info "Starting full system upgrade (syncing all installed packages)..."
    local count=0
    local success_count=0
    
    update_repo || info "Warning: Could not update remote index. Continuing with local recipes."

    info "\nChecking all installed packages for updates..."

    # Use find to list all installed packages by their path (e.g., app-editors/nano)
    find "$DB_DIR" -type f -name "version" -maxdepth 3 2>/dev/null | 
    sed "s|^${DB_DIR}/||" | sed 's|/version$||' |
    while IFS= read -r pkg_path; do
        local pkg=$(basename "$pkg_path")
        info "\n>>> Checking $pkg_path <<<"
        if sync_pkg_recursive "$pkg"; then
            success_count=$((success_count + 1))
        else
            info "Warning: Failed to sync $pkg_path. Check logs."
        fi
        count=$((count + 1))
    done
    
    info "\nUpgrade process finished. Checked $count installed packages. $success_count updated/verified."
}


self_update() {
    TMPDIR="${TMPDIR:-/tmp}"
    
    local tmp_file
    tmp_file=$(mktemp "$TMPDIR/astral-new.XXXXXX")
    if [ $? -ne 0 ]; then
        err "Failed to create secure temporary file using mktemp."
    fi

    trap 'rm -f "$tmp_file"' EXIT

    local branch="${1:-main}"
    local update_url=""
    
    case "$branch" in
        main)
            update_url="$SELF_UPDATE_URL_MAIN"
            info "Starting astral self-update from 'main' branch ($update_url)..."
            ;;
        cutting-edge)
            update_url="$SELF_UPDATE_URL_CUTTING_EDGE"
            info "Starting astral self-update from 'cutting-edge' branch ($update_url)..."
            ;;
        bleeding-edge)
            update_url="$SELF_UPDATE_URL_BLEEDING_EDGE"
            info "Starting astral self-update from 'bleeding-edge' branch ($update_url)..."
            ;;
        *)
            err "Unknown update branch/channel '$branch'. Please use 'main' (default), 'cutting-edge', or 'bleeding-edge'."
            return 1 
            ;;
    esac

    command -v curl >/dev/null 2>&1 || { err "curl not found."; return 1; }

    if [ -z "$update_url" ]; then
        err "Internal error: Update URL is empty."
        return 1
    fi

    if ! curl -fsSL "$update_url" -o "$tmp_file"; then
        err "Failed to download new astral script from $update_url."
        return 1
    fi
    
    if ! head -n 1 "$tmp_file" | grep -qE '^#!([[:space:]]*/bin/sh|[[:space:]]*/usr/bin/env)'; then
        err "Downloaded file invalid (missing shebang or invalid content)."
        return 1
    fi
    
    if [ ! -s "$tmp_file" ]; then
        err "Downloaded file is empty or too small. Download failed."
        return 1
    fi

    chmod +x "$tmp_file"
    if mv -f "$tmp_file" "$SELF_UPDATE_PATH"; then
        info "Self-update successful! New script installed to $SELF_UPDATE_PATH."
        trap - EXIT 
    else
        err "Failed to replace $SELF_UPDATE_PATH. Check permissions."
        return 1
    fi
}

remove_pkg() {
    local requested_pkg="$1"
    
    # 1. Resolve the actual path (e.g., 'app-editors/nano') from the simple name or full path
    local pkg_path
    pkg_path=$(resolve_installed_path "$requested_pkg") || err "package $requested_pkg not installed"
    
    local pkgdir="$DB_DIR/$pkg_path"

    # 2. Sanitize the package path for use in the temporary filename (BUG FIX)
    local safe_pkg_name=$(echo "$pkg_path" | tr '/' '_')
    local dirs_file="$TMPDIR/astral-dirs-${safe_pkg_name}-$$"
    
    trap "rm -f '$dirs_file'" EXIT 

    # Use the improved recipe_path to find the hook location
    local rpath=$(recipe_path "$(basename "$pkg_path")") 
    
    # --- PRE-REMOVE HOOK ---
    if [ -n "$rpath" ] && [ -f "$rpath/post_remove" ]; then
        info "Running post_remove hook for $(basename "$pkg_path")..."
        ( "$rpath/post_remove" ) || info "Warning: post_remove hook failed for $(basename "$pkg_path"), continuing removal."
    fi
    
    info "Removing $pkg_path files from $INSTALL_ROOT"
    
    while IFS= read -r f; do
        [ -z "$f" ] && continue
        
        local fullpath="$INSTALL_ROOT/$f"
        
        if [ -d "$fullpath" ]; then
            printf "%s\n" "$f" >> "$dirs_file"
        elif [ -e "$fullpath" ]; then
            rm -f "$fullpath"
        fi
    done < "$pkgdir/files"
    
    # 3. Process collected directories (deepest first)
    if [ -f "$dirs_file" ]; then
        info "Attempting to clean up empty directories installed by $pkg_path..."
        sort -r "$dirs_file" | while IFS= read -r d; do
            [ -z "$d" ] && continue
            local dir_path="$INSTALL_ROOT/$d"
            rmdir "$dir_path" 2>/dev/null || : # Ignore failure if not empty
        done
        rm -f "$dirs_file"
    fi
    
    trap - EXIT
    rm -rf "$pkgdir"
    info "Removed $pkg_path successfully from database."
}

removedep_pkg() {
    local pkg="$1"
    
    # Get the canonical path for the initial package removal
    local initial_pkg_path
    initial_pkg_path=$(resolve_installed_path "$pkg") || err "package $pkg not installed"

    remove_pkg "$initial_pkg_path"
    info "Scanning for orphaned dependencies..."
    
    while true; do
        found_orphan=0
        # Iterate over all installed package directories
        find "$DB_DIR" -type f -name "version" -maxdepth 3 2>/dev/null | 
        sed "s|^${DB_DIR}/||" | sed 's|/version$||' |
        while IFS= read -r dep_path; do
            # Check if package is required (uses the full path for is_pkg_required check)
            if ! is_pkg_required "$dep_path"; then
                info "Removing orphan dependency: $dep_path"
                remove_pkg "$dep_path" # remove_pkg accepts the full path
                found_orphan=1
                break # Break inner loop to restart the dependency scan
            fi 
        done
        [ "$found_orphan" -eq 0 ] && break
    done
    info "Orphan dependency scan complete."
}

clean_cache() {
    info "Starting recipe cache cleanup in $RECIPES_DIR..."
    local cleaned_count=0
    
    # Use find to iterate through all package directories (maxdepth 2 ensures category/pkg)
    find "$RECIPES_DIR" -type d -mindepth 2 -maxdepth 2 2>/dev/null | while IFS= read -r recipe_dir; do
        local pkg_name=$(basename "$recipe_dir")
        
        if is_pkg_installed "$pkg_name"; then
            info "Recipe for '$pkg_name' is installed. Skipping."
        else
            info "Recipe for '$pkg_name' is NOT installed. Removing cache files..."
            rm -rf "$recipe_dir"
            cleaned_count=$((cleaned_count + 1))
        fi
    done
    
    # Note: cleaned_count outside the loop will be 0 due to subshell. 
    info "Cache cleanup process initiated. Check output for removed recipes."
}

list_installed() {
    if [ ! -d "$DB_DIR" ] || [ -z "$(ls -A "$DB_DIR" 2>/dev/null)" ]; then
        info "No packages currently installed."
        return 0
    fi

    info "--- Installed Packages ---"
    
    local last_category=""
    
    # 1. Find all 'version' files recursively, strip the DB_DIR prefix, and sort by path
    # This finds package entries like 'app-editors/nano' or just 'package-name'
    find "$DB_DIR" -type f -name "version" -maxdepth 3 2>/dev/null | 
    sed "s|^${DB_DIR}/||" | sed 's|/version$||' | sort |
    
    # 2. Loop through each discovered package path (e.g., app-editors/nano, base/coreutils)
    while IFS= read -r pkg_path; do
        local pkg_name=$(basename "$pkg_path")
        local category=$(dirname "$pkg_path")
        local pkg_ver=""
        
        # Fallback for root-level packages if dirname is '.'
        if [ "$category" = "." ] || [ -z "$category" ] || [ "$category" = "/" ]; then
            category="Uncategorized"
        fi
        
        # Check if category has changed (or is the first one)
        if [ "$category" != "$last_category" ]; then
            printf '\n---Installed-package---\n'
            printf '%s\n' "$category"
            last_category="$category"
        fi
        
        # Get the version from the database path
        if [ -f "$DB_DIR/$pkg_path/version" ]; then
             pkg_ver=$(cat "$DB_DIR/$pkg_path/version")
        fi
        
        printf "|- %-15s (v%s)\n" "$pkg_name" "$pkg_ver"
        
    done
    printf '\n'
}

# CLI dispatch

# Feature 1: Root Check
if ! echo "$@" | grep -qE '(-V|--version|-u|--update|--search|--inspect|-ins|-I|--info|--list-installed|-ll)'; then
    if [ "$(id -u)" -ne 0 ]; then 
        err "Astral must be run as root (UID 0) to perform installation, removal, or self-update operations."
    fi
fi

# --- Global Option Parsing ---
while [ $# -gt 0 ]; do
    case "$1" in
        -f|--force)
            FORCE_INSTALL=1
            info "Global: Force mode activated."
            shift
            ;;
        --dir)
            [ $# -lt 2 ] && err "Missing argument for $1"
            INSTALL_ROOT="$2"
            shift 2
            ;;
        --dir=*)
            INSTALL_ROOT="${1#*=}"
            shift
            ;;
        -V|--version)
            astral_version
            ;;
        --) # End of options
            shift
            break
            ;;
        -*) # Unknown option or command (or a command itself)
            break
            ;;
        *) # Command (or package name)
            break
            ;;
    esac
done

if [ $# -lt 1 ]; then usage; exit 1; fi

# Ensure INSTALL_ROOT has no trailing slash (unless it is just "/")
if [ "$INSTALL_ROOT" != "/" ]; then
    INSTALL_ROOT="${INSTALL_ROOT%/}"
    info "Global: Installation root set to: $INSTALL_ROOT"
fi

# Now $1 is the command, and $2, $3... are its arguments.

case "$1" in
  -s|--sync)
    [ $# -gt 1 ] || err "package name required"
    sync_pkg_recursive "$2"
    ;;
  -comp|--compile)
    [ $# -gt 1 ] || err "package name required"
    build_from_recipe "$2"
    ;;
  -u|--update)
    update_repo
    ;;
  --search)
    [ $# -gt 1 ] || err "package name required"
    search_pkg "$2"
    ;;
  -R|--Remove)
    [ $# -gt 1 ] || err "package name required"
    remove_pkg "$2"
    ;;
  -r|--RemoveDep)
    [ $# -gt 1 ] || err "package name required"
    removedep_pkg "$2"
    ;;
  -Cc|--Clean-Cache)
    clean_cache
    ;;
  -U|--self-update)
    self_update "${2:-main}"
    ;;
  --info|-I)
    [ $# -gt 1 ] || err "package name required"
    show_pkg_info "$2"
    ;;
  --upgrade-all|-ua)
    upgrade_all
    ;;
  --inspect|-ins)
    [ $# -gt 1 ] || err "package name required"
    r=$(recipe_path "$2") || err "recipe not found for "$2""
    info "--- Files in Recipe Directory: $r ---"
    if [ -d "$r" ]; then
      ls -la "$r"
      [ -f "$r/info" ] && { info "\n--- PACKAGE INFO ($2) ---\n"; cat "$r/info"; }
      [ -f "$r/build" ] && { info "\n--- BUILD SCRIPT HEAD ($2) ---\n"; sed -n '1,20p' "$r/build"; }
    else
      info "--- Single Recipe File Content ($2) ---\n"
      sed -n '1,20p' "$r"
    fi
    ;;
  --list-installed|-ll)
    list_installed
    ;;
  *)
    echo "Error: Unknown command or option '$1'" >&2
    usage
    exit 1
    ;;
esac

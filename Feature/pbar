#!/bin/sh
# Astral v0.4.9.0 - minimal POSIX package manager for Astaraxia
# Rewritten to emulate Arch Linux's pacman look and feel.

# Set strict execution environment
set -eu

# --- ANSI Color Codes for Pacman Style ---
COLOR_GREEN='\033[1;32m' # Bold Green (:: for sync/update)
COLOR_YELLOW='\033[1;33m' # Bold Yellow (:: for prompt)
COLOR_RED='\033[1;31m' # Bold Red (:: for error)
COLOR_BLUE='\033[1;34m' # Bold Blue (-> for actions)
COLOR_RESET='\033[0m' # Reset color
CLEAR_LINE='\033[K' # Clear to end of line

# Global state variables
INSTALL_ROOT="/"
FORCE_INSTALL=0

# Directory Layout
RECIPES_DIR=${RECIPES_DIR:-/usr/src/astral/recipes}
CACHE_SRC=${CACHE_SRC:-/var/cache/astral/src}
CACHE_BIN=${CACHE_BIN:-/var/cache/astral/bin}
DB_DIR=${DB_DIR:-/var/lib/astral/db}
REPO_URL=${REPO_URL:-https://izumi-sonoka.github.io/Astral-Repo/}
RECIPE_RAW_URL=${RECIPE_RAW_URL:-https://raw.githubusercontent.com/Izumi-Sonoka/Astral-Repo/main}
INDEX_FILE="$DB_DIR/index"
LOG_DIR=${LOG_DIR:-/var/log/astral}
SELF_UPDATE_URL_MAIN=${SELF_UPDATE_URL_MAIN:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/main/astral}
SELF_UPDATE_PATH=/usr/bin/astral
TMPDIR=${TMPDIR:-/tmp}

mkdir -p "$RECIPES_DIR" "$CACHE_SRC" "$CACHE_BIN" "$DB_DIR" "$LOG_DIR" "$TMPDIR"

# MODIFIED: Pacman-style status functions
err() { printf "${COLOR_RED}:: %sERROR:%s %s\n" "$COLOR_RED" "$COLOR_RESET" "$*" >&2; exit 1; }
prompt_status() { printf "${COLOR_YELLOW}:: %s%s\n" "$*" "$COLOR_RESET"; }
action_status() { printf "${COLOR_BLUE}-> %s%s\n" "$*" "$COLOR_RESET"; }
sync_status() { printf "${COLOR_GREEN}:: %s%s\n" "$*" "$COLOR_RESET"; }

version="0.4.9.0"

pacman_version() {
cat <<EOF
Astral Package Manager (pacman emulation) v$version
.
Copyright (C) 2025 Astaraxia Linux
This is free software; see the source for copying conditions.
There is NO WARRANTY, to the extent permitted by law.
EOF
    exit 0
}

usage() {
    cat <<USAGE
Usage: pacman.sh <operation> [options] [targets]

Operations:
  -S, --sync           Synchronize and install packages.
  -R, --remove         Remove packages.
  -Q, --query          Query the package database.
  -U, --upgrade        Upgrade the package manager itself.

Operation Options:
  -y, --refresh        Download fresh package databases from the server.
  -u, --sysupgrade     Upgrade all currently installed packages.
  -i, --info           View package information.
  -s, --search         Search locally and remotely for a package.
  -d, --nodeps         Skip dependency checks (Dangerous!).
  -r, --recursive      Remove package and its unneeded dependencies (Orphans).
  -c, --clean          Clean up cached recipe files.
  -f, --force          Force installation/removal (e.g., bypass conflict checks).
  --dir <DIR>          Specify root directory for installing packages (defaults to /).
  --compile            Force build from recipe and install (for -S only).

General Options:
  -V, --version        Show Astral version.
USAGE
}

# --- CORE UTILITY FUNCTIONS ---

# Global variables for progress tracking
GLOBAL_PROGRESS_TOTAL=0
GLOBAL_PROGRESS_CURRENT=0

# MODIFIED: Implements single-line Pacman-style status bar using \r
astral_progress() {
    local current="$1"
    local total="$2"
    local title_prefix="$3" # e.g., "Extracting neofetch"

    [ "$total" -le 0 ] && total=1 # Avoid division by zero

    # Calculate percentage (simple integer arithmetic for POSIX compliance)
    local percent_calc=$((100 * current / total))
    
    # Use :: and \r for pacman-style overwrite
    printf "\r${COLOR_GREEN}::%s %s (%s/%s) %s%%%s" "$COLOR_RESET" "$title_prefix" "$current" "$total" "$percent_calc" "$CLEAR_LINE"
}

# MODIFIED: Finalizes the Pacman-style status
astral_progress_finish() {
    local title_prefix="$1" # e.g., "Extracting neofetch"
    
    # Substitute "Extracting" with "Extracted" for the final message, clear the line (\033[K), and add a newline
    printf "\r${COLOR_GREEN}::%s %s (100%%)${CLEAR_LINE}\n" "$COLOR_RESET" "${title_prefix/Extracting/Extracted}"
}

is_pkg_installed() { pkg="$1"; [ -d "$DB_DIR/$pkg" ]; }

recipe_path() {
    pkg="$1"
    [ -f "$RECIPES_DIR/$pkg/build" ] && echo "$RECIPES_DIR/$pkg" && return 0
    [ -f "$RECIPES_DIR/$pkg.astral" ] && echo "$RECIPES_DIR/$pkg.astral" && return 0
    return 1
}

get_installed_ver() {
    local pkg="$1"
    if [ -f "$DB_DIR/$pkg/version" ]; then
        cat "$DB_DIR/$pkg/version"
    else
        echo "none"
    fi
}

get_pkg_deps() {
    local pkg="$1"
    local depfile="$DB_DIR/$pkg/depends"
    [ -f "$depfile" ] || { 
        local rpath=$(recipe_path "$pkg")
        [ -n "$rpath" ] && depfile="$rpath/depends"
    }

    [ -f "$depfile" ] || return 0
    cat "$depfile" | grep -v '^[[:space:]]*#' | grep -E -v '^[[:space:]]*$'
}

is_pkg_required() {
    local target_pkg="$1"
    for other_pkg_dir in "$DB_DIR"/*; do
        [ -d "$other_pkg_dir" ] || continue
        local other_pkg=$(basename "$other_pkg_dir")
        [ -z "$other_pkg" ] && continue
        [ "$other_pkg" = "$target_pkg" ] && continue
        if [ -f "$other_pkg_dir/depends" ]; then
            if cat "$other_pkg_dir/depends" | grep -v '^[[:space:]]*#' | grep -E -v '^[[:space:]]*$' | grep -q "^${target_pkg}$"; then
                return 0 # Required
            fi
        fi
    done
    return 1 # Not required
}

# --- NETWORKING & BUILD FUNCTIONS ---

fetch_remote_recipe() {
    local pkg="$1"
    local local_dir="$RECIPES_DIR/$pkg"
    
    sync_status "Downloading recipe for '$pkg'..."
    
    mkdir -p "$local_dir"

    local required_files="version build sources"
    local optional_files="depends package post_install post_remove checksums conflicts info"
    
    local clean_raw_url="${RECIPE_RAW_URL%/}"
    local remote_base="${clean_raw_url}/recipes/$pkg"

    for file in $required_files $optional_files; do
        local url="$remote_base/$file"
        local dest="$local_dir/$file"
        
        # Download silently (-s), fail on 404 (-f).
        # We don't use -# here to keep the terminal clean of curl's progress.
        if curl -fsSL "$url" -o "$dest" 2>/dev/null; then
            :
        else
            if echo "$required_files" | grep -q "$file"; then
                err "Failed to fetch mandatory file '$file' for package '$pkg'."
                rm -rf "$local_dir"
                return 1
            fi
            rm -f "$dest"
        fi
    done
    
    chmod +x "$local_dir/build" 2>/dev/null || true
    chmod +x "$local_dir/package" 2>/dev/null || true
    chmod +x "$local_dir/post_install" 2>/dev/null || true
    chmod +x "$local_dir/post_remove" 2>/dev/null || true
    
    action_status "Recipe for '$pkg' refreshed."
}

fetch_and_extract_sources() {
    local pkg="$1"
    local rpath="$2"
    local buildtmp="$3"
    
    local sources_file="$rpath/sources"
    [ -f "$sources_file" ] || return 0

    sync_status "Downloading sources for $pkg (this may take a moment)..."
    
    GLOBAL_PROGRESS_TOTAL=$(grep -v '^[[:space:]]*#' "$sources_file" | grep -E -v '^[[:space:]]*$' | wc -l)
    GLOBAL_PROGRESS_CURRENT=0
    
    while IFS= read -r url; do
        url=$(echo "$url" | tr -d '[:space:]')
        [ -z "$url" ] && continue
        [ "${url:0:1}" = "#" ] && continue
        
        local filename=$(basename "$url")
        local dest_file="$buildtmp/$filename"
        
        action_status "Downloading $filename"
        # Using curl -# provides a basic progress bar to stderr
        if curl -fsSL -# "$url" -o "$dest_file"; then
            :
        else
            err "Failed to download source file from $url"
        fi
    done < "$sources_file"
}

verify_checksums_and_extract() {
    local pkg="$1"
    local rpath="$2"
    local buildtmp="$3"
    
    local checksums_file="$rpath/checksums"
    [ -f "$checksums_file" ] || { action_status "No checksums provided for $pkg. Skipping integrity check."; return 0; }
    
    command -v sha256sum >/dev/null 2>&1 || err "sha256sum command not found. Cannot verify source integrity."

    sync_status "Verifying source integrity..."
    
    # Verification step
    while IFS= read -r line; do
        line=$(echo "$line" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
        [ -z "$line" ] && continue
        [ "${line:0:1}" = "#" ] && continue
        
        local expected_hash=$(echo "$line" | awk '{print $1}')
        local filename=$(echo "$line" | awk '{print $2}')
        local file_path="$buildtmp/$filename"

        [ ! -f "$file_path" ] && err "Checksum error: Source file '$filename' not found."

        local actual_hash=$(sha256sum "$file_path" | awk '{print $1}')
        
        if [ "$actual_hash" != "$expected_hash" ]; then
            err "Checksum mismatch for $filename! Aborting."
        fi
    done < "$checksums_file"

    action_status "All checksums verified."
    sync_status "Extracting sources..."
    
    local sources_file="$rpath/sources"
    
    if [ "$GLOBAL_PROGRESS_TOTAL" -eq 0 ]; then
        GLOBAL_PROGRESS_TOTAL=$(grep -v '^[[:space:]]*#' "$sources_file" | grep -E -v '^[[:space:]]*$' | wc -l)
    fi

    GLOBAL_PROGRESS_CURRENT=0
    
    while IFS= read -r url; do
        url=$(echo "$url" | tr -d '[:space:]')
        [ -z "$url" ] && continue
        [ "${url:0:1}" = "#" ] && continue
        
        local filename=$(basename "$url")
        local dest_file="$buildtmp/$filename"
        
        GLOBAL_PROGRESS_CURRENT=$((GLOBAL_PROGRESS_CURRENT + 1))
        
        astral_progress "$GLOBAL_PROGRESS_CURRENT" "$GLOBAL_PROGRESS_TOTAL" "Extracting $pkg"

        # Attempt to extract common archive formats. Silence output for clean progress.
        case "$filename" in
            *.tar.gz|*.tgz) tar -xf "$dest_file" -C "$buildtmp" 2>/dev/null || err "Tar extract failed for $filename" ;;
            *.tar.bz2|*.tbz) tar -xf "$dest_file" -C "$buildtmp" 2>/dev/null || err "Bzip2 extract failed for $filename" ;;
            *.tar.xz|*.txz) tar -xf "$dest_file" -C "$buildtmp" 2>/dev/null || err "XZ extract failed for $filename" ;;
            *.zip) unzip -q "$dest_file" -d "$buildtmp" 2>/dev/null || err "Unzip failed for $filename" ;;
            *) ;; 
        esac
    done < "$sources_file"

    astral_progress_finish "Extracting $pkg"
}

build_from_recipe() {
    local pkg="$1"
    local rpath
    rpath=$(recipe_path "$pkg") || err "recipe $pkg not found"
    
    local recipe_ver=$(cat "$rpath/version" 2>/dev/null || echo "unknown")
    local installed_ver=$(get_installed_ver "$pkg")
    
    if [ "$installed_ver" != "none" ]; then
        if [ "$installed_ver" = "$recipe_ver" ] && [ "$FORCE_INSTALL" -eq 0 ]; then
            sync_status "Package '$pkg' is already installed at version $installed_ver. Up to date. Skipping build."
            return 0
        elif [ "$installed_ver" != "$recipe_ver" ]; then
            sync_status "Upgrading '$pkg' from $installed_ver to $recipe_ver..."
        else
            sync_status "Force-rebuilding '$pkg' version $recipe_ver."
        fi
    else
        sync_status "Installing '$pkg' version $recipe_ver..."
    fi

    local buildtmp="$TMPDIR/astral-build-$pkg-$$"
    mkdir -p "$buildtmp"
    
    if [ -d "$rpath" ]; then
        cp -a "$rpath"/* "$buildtmp"/
    else
        cp -a "$rpath" "$buildtmp/recipe.astral"
    fi
    cd "$buildtmp"

    trap "rm -rf '$buildtmp'" EXIT 

    # 1. Fetch source
    fetch_and_extract_sources "$pkg" "$rpath" "$buildtmp"
    
    # 2. Verify Checksums and Extract (with progress bar)
    verify_checksums_and_extract "$pkg" "$rpath" "$buildtmp"

    if [ -f "./build" ]; then
        action_status "Building $pkg..."
        chmod +x ./build || true
        local PKGDIR="$buildtmp/pkg"
        mkdir -p "$PKGDIR"
        
        # Isolated Build
        ( DESTDIR="$PKGDIR" ./build ) || err "build failed for $pkg" 
        
        # Packaging
        if [ -f "./package" ]; then
            action_status "Running package hook..."
            ( DESTDIR="$PKGDIR" PKGDIR="$PKGDIR" ./package ) || err "package() failed for $pkg"
        fi
        
        # Install to target root
        action_status "Installing $pkg files to $INSTALL_ROOT..."
        
        # Create metadata (minimal version of .PKGINFO)
        printf "name=%s\nversion=%s\narch=%s\n" "$pkg" "$recipe_ver" "x86_64" > "$PKGDIR/.astral-meta"

        tar -C "$PKGDIR" -cf - . | tar -C "$INSTALL_ROOT" -xf - || err "Failed to extract package files"
        
        # Record database
        local pkgdir="$DB_DIR/$pkg"
        mkdir -p "$pkgdir"
        printf '%s\n' "$recipe_ver" > "$pkgdir/version"
        
        # Record files list
        ( cd "$PKGDIR" && find . -mindepth 1 -print ) \
        | sed 's/^\.\///' \
        | grep -v '^\.astral-meta$' \
        | printf '%s\n' > "$pkgdir/files" || true

        if [ -f "$buildtmp/depends" ]; then
            cp "$buildtmp/depends" "$pkgdir/depends"
        fi
        
        # Post-Install Hook
        if [ -f "$buildtmp/post_install" ]; then
            action_status "Running post_install hook..."
            ( DESTDIR="$INSTALL_ROOT" PKGDIR="$PKGDIR" "$buildtmp/post_install" ) || action_status "Warning: post_install hook failed."
        fi
        
        sync_status "Successfully installed $pkg ($recipe_ver)."
    else
        err "Recipe $pkg has no build script"
    fi
    
    trap - EXIT
    rm -rf "$buildtmp"
}

update_repo() {
    sync_status "Synchronizing package database..."
    local INDEX_URL="${REPO_URL}astral.index"
    if curl -fsSL "$INDEX_URL" -o "$INDEX_FILE"; then
        sync_status "Database updated successfully."
    else
        err "Failed to download index file from $INDEX_URL."
        return 1
    fi
}

sync_pkg_recursive() {
    local pkg="$1"
    
    action_status "Resolving dependencies for $pkg..."

    # 1. Ensure we have the recipe
    fetch_remote_recipe "$pkg"

    local recipe_dir="$(recipe_path "$pkg")"
    [ -z "$recipe_dir" ] && err "Recipe for '$pkg' could not be found."

    # 2. Handle Dependencies (Recursive)
    get_pkg_deps "$pkg" | while IFS= read -r dep_pkg; do
        dep_pkg=$(echo "$dep_pkg" | tr -d '[:space:]')
        [ -z "$dep_pkg" ] && continue
        
        sync_pkg_recursive "$dep_pkg"
    done

    # 3. Build/Install
    build_from_recipe "$pkg"
}

upgrade_all() {
    # 1. Update index first
    update_repo || action_status "Warning: Could not update remote index. Continuing with local recipes."

    sync_status "Starting full system upgrade..."
    local success_count=0
    
    for pkg_dir in "$DB_DIR"/*; do
        if [ -d "$pkg_dir" ]; then
            local pkg=$(basename "$pkg_dir")
            sync_status "Checking $pkg for update..."
            # sync_pkg_recursive handles the version check/skip internally
            if sync_pkg_recursive "$pkg"; then
                success_count=$((success_count + 1))
            else
                action_status "Warning: Failed to sync $pkg. Skipping."
            fi
        fi
    done
    sync_status "System upgrade finished. $success_count package(s) updated/verified."
}

remove_pkg() {
    pkg="$1"
    pkgdir="$DB_DIR/$pkg"
    [ -d "$pkgdir" ] || err "package $pkg not installed"

    action_status "Checking dependency requirements..."
    # Check if other packages require this one
    if is_pkg_required "$pkg" && [ "$FORCE_INSTALL" -eq 0 ]; then
        err "Package '$pkg' is required by other installed packages. Use -f to force removal."
    fi

    local dirs_file="$TMPDIR/astral-dirs-$pkg-$$"
    trap "rm -f '$dirs_file'" EXIT 

    # Pre-Remove Hook
    local rpath=$(recipe_path "$pkg")
    if [ -f "$rpath/post_remove" ]; then
        action_status "Running post_remove hook..."
        ( "$rpath/post_remove" ) || action_status "Warning: post_remove hook failed, continuing removal."
    fi

    sync_status "Removing $pkg..."
    
    # 1. Read files list, remove files, and collect directories
    while IFS= read -r f; do
        [ -z "$f" ] && continue
        local fullpath="$INSTALL_ROOT/$f"
        
        if [ -d "$fullpath" ]; then
            printf "%s\n" "$f" >> "$dirs_file"
        elif [ -e "$fullpath" ]; then
            action_status "Deleting file: $f"
            rm -f "$fullpath"
        fi
    done < "$pkgdir/files"
    
    # 2. Process collected directories (deepest first)
    if [ -f "$dirs_file" ]; then
        action_status "Cleaning up empty directories..."
        sort -r "$dirs_file" | while IFS= read -r d; do
            [ -z "$d" ] && continue
            local dir_path="$INSTALL_ROOT/$d"
            if rmdir "$dir_path" 2>/dev/null; then
                action_status "Deleted empty directory: $dir_path"
            fi
        done
        rm -f "$dirs_file"
    fi
    
    trap - EXIT
    rm -rf "$pkgdir"
    sync_status "Removed $pkg successfully."
}

removedep_pkg() {
    pkg="$1"
    # Step 1: Remove the requested package first
    remove_pkg "$pkg"

    prompt_status "Scanning for orphaned dependencies..."
    while true; do
        local orphans="" 
        for dep_dir in "$DB_DIR"/*; do
            [ -d "$dep_dir" ] || continue
            dep_name=$(basename "$dep_dir")
            if is_pkg_installed "$dep_name" && ! is_pkg_required "$dep_name"; then
                orphans="$orphans $dep_name"
            fi 
        done
        
        if [ -n "$orphans" ]; then
            prompt_status "The following packages are no longer required:"
            for orphan_name in $orphans; do
                printf "  %s %-20s (v%s)\n" "  " "$orphan_name" "$(get_installed_ver "$orphan_name")"
            done
            
            printf "${COLOR_YELLOW}::%s Remove orphaned packages? [Y/n] %s" "$COLOR_RESET"
            read -r confirmation

            if [ -z "$confirmation" ] || [ "$confirmation" = "y" ] || [ "$confirmation" = "Y" ]; then
                for orphan_name in $orphans; do
                    sync_status "Removing orphan dependency: $orphan_name"
                    remove_pkg "$orphan_name"
                done
            else
                sync_status "Skipping removal of orphaned dependencies."
                break
            fi
        else
            break
        fi
    done
    sync_status "Orphan dependency scan complete."
}

clean_cache() {
    sync_status "Starting cache cleanup in $RECIPES_DIR..."
    local cleaned_count=0
    for recipe_dir in "$RECIPES_DIR"/*; do
        if [ ! -d "$recipe_dir" ]; then
            continue
        fi
        local pkg=$(basename "$recipe_dir")
        
        if is_pkg_installed "$pkg"; then
            action_status "Recipe for '$pkg' is installed. Keeping."
        else
            action_status "Recipe for '$pkg' is NOT installed. Removing..."
            rm -rf "$recipe_dir"
            cleaned_count=$((cleaned_count + 1))
        fi
    done
    sync_status "Cache cleanup complete. Removed $cleaned_count orphaned recipe(s)."
}

show_pkg_info() {
    local pkg="$1"
    local rpath=$(recipe_path "$pkg")
    local recipe_exists=1
    [ -z "$rpath" ] && recipe_exists=0
    
    sync_status "Package Information: $pkg"
    
    local installed_ver=$(get_installed_ver "$pkg")
    printf "  %s%-18s: %s\n" "${COLOR_GREEN}" "Installed Version" "$installed_ver${COLOR_RESET}"
    if [ "$installed_ver" != "none" ]; then
        printf "  %-18s: %s\n" "Installed Path" "$DB_DIR/$pkg"
    fi
    
    if [ "$recipe_exists" -eq 1 ]; then
        local recipe_ver=$(cat "$rpath/version" 2>/dev/null || echo "unknown")
        printf "  %s%-18s: %s\n" "${COLOR_YELLOW}" "Latest Version" "$recipe_ver${COLOR_RESET}"
        
        local deps_list="None"
        local conflicts_list="None"

        local filtered_deps=$(get_pkg_deps "$pkg")
        [ -n "$filtered_deps" ] && deps_list=$(echo "$filtered_deps" | tr '\n' ' ')

        if [ -f "$rpath/conflicts" ]; then
            local filtered_conflicts=$(cat "$rpath/conflicts" | grep -v '^[[:space:]]*#' | grep -E -v '^[[:space:]]*$')
            [ -n "$filtered_conflicts" ] && conflicts_list=$(echo "$filtered_conflicts" | tr '\n' ' ')
        fi

        printf "  %-18s: %s\n" "Dependencies" "$deps_list"
        printf "  %-18s: %s\n" "Conflicts" "$conflicts_list"
    else
        printf "  ${COLOR_RED}Recipe Not Found${COLOR_RESET}\n"
    fi
}

search_pkg() {
    local query="$1"
    sync_status "Searching for packages matching '$query'..."
    
    # Local Recipes
    for r in "$RECIPES_DIR"/*; do
        if [ -d "$r" ]; then
            local pkg_name=$(basename "$r")
            if echo "$pkg_name" | grep -iq "$query"; then
                local ver=$(cat "$r/version" 2>/dev/null || echo "unknown")
                printf "    ${COLOR_BLUE}local/%s${COLOR_RESET} (${COLOR_GREEN}v%s${COLOR_RESET})\n" "$pkg_name" "$ver"
            fi
        fi
    done

    # Remote Index
    [ -f "$INDEX_FILE" ] || { action_status "Remote index not found. Run 'pacman.sh -Sy'."; return 0; }
    while IFS= read -r line; do
        local pkg_name=$(echo "$line" | awk '{print $1}')
        local pkg_ver=$(echo "$line" | awk '{print $2}')
        if echo "$pkg_name" | grep -iq "$query"; then
            printf "    ${COLOR_GREEN}remote/%s${COLOR_RESET} (${COLOR_YELLOW}v%s${COLOR_RESET})\n" "$pkg_name" "$pkg_ver"
        fi
    done < "$INDEX_FILE"
}

query_installed() {
    sync_status "Installed Packages:"
    for d in "$DB_DIR"/*; do
        [ -d "$d" ] || continue
        printf "    %-20s (${COLOR_GREEN}v%s${COLOR_RESET})\n" "$(basename "$d")" "$(cat "$d/version" 2>/dev/null || echo unknown)"
    done
}

# --- CLI DISPATCHER ---

if [ $# -lt 1 ]; then usage; exit 1; fi

# Check for root privilege
if ! echo "$@" | grep -q '\(--search\|--inspect\|--info\|--version\|-V\|-Q\|-s\|-y\)'; then
    if [ "$(id -u)" -ne 0 ]; then 
        err "Operation requires root privileges (use sudo or run as root)."
    fi
fi

# Parse global flags
FORCE_COMPILE=0
while true; do
    case "$1" in
        -f|--force) FORCE_INSTALL=1; shift ;;
        --compile) FORCE_COMPILE=1; shift ;;
        --dir) [ $# -lt 2 ] && err "Missing argument for $1"; INSTALL_ROOT="$2"; shift 2 ;;
        --dir=*) INSTALL_ROOT="${1#*=}"; shift ;;
        -V|--version) pacman_version ;;
        --) shift; break ;;
        -*) break ;; # Stop parsing global flags when we hit an operation flag
        *) break ;;
    esac
done

# Check if an operation is left
if [ $# -lt 1 ]; then usage; exit 1; fi

# Normalize INSTALL_ROOT
if [ "$INSTALL_ROOT" != "/" ]; then
    INSTALL_ROOT="${INSTALL_ROOT%/}"
    action_status "Installation root set to: $INSTALL_ROOT"
fi

# Main Operation Dispatch (Pacman Style)
OPERATION="$1"; shift
case "$OPERATION" in
    -S|--sync)
        # Check for -y/--refresh flag (sync databases)
        if echo "$@" | grep -q '^-y\|--refresh'; then
            update_repo
        fi
        
        # Check for -u/--sysupgrade flag (upgrade all)
        if echo "$@" | grep -q '^-u\|--sysupgrade'; then
            upgrade_all
        
        # Check for -s/--search flag (search)
        elif echo "$@" | grep -q '^-s\|--search'; then
            # Find the next argument that is NOT a flag
            local search_query=""
            for arg in "$@"; do
                if [ "${arg#-}" = "$arg" ]; then # Is not a flag (doesn't start with -)
                    search_query="$arg"
                    break
                fi
            done
            [ -z "$search_query" ] && err "Search query required for -Ss"
            search_pkg "$search_query"

        # Check for -i/--info flag (show info)
        elif echo "$@" | grep -q '^-i\|--info'; then
            # Find the next argument that is NOT a flag
            local info_pkg=""
            for arg in "$@"; do
                if [ "${arg#-}" = "$arg" ]; then
                    info_pkg="$arg"
                    break
                fi
            done
            [ -z "$info_pkg" ] && err "Package name required for -Si"
            show_pkg_info "$info_pkg"
            
        # Default: Install/Sync specific package(s)
        elif [ $# -gt 0 ]; then
            for pkg in "$@"; do
                # Skip flags, only process package names
                if [ "${pkg#-}" = "$pkg" ]; then
                    sync_status "Target: $pkg"
                    if [ "$FORCE_COMPILE" -eq 1 ]; then
                        build_from_recipe "$pkg"
                    else
                        sync_pkg_recursive "$pkg"
                    fi
                fi
            done
        elif ! echo "$@" | grep -q '^-'; then # -S alone with no targets, flags handled above
            usage; exit 1
        fi
        ;;

    -R|--remove)
        [ $# -gt 0 ] || err "Package name required for -R"
        
        # Check for -r/--recursive flag (remove orphans)
        if echo "$@" | grep -q '^-r\|--recursive'; then
            for pkg in "$@"; do
                if [ "${pkg#-}" = "$pkg" ]; then
                    removedep_pkg "$pkg"
                fi
            done
        else
            for pkg in "$@"; do
                if [ "${pkg#-}" = "$pkg" ]; then
                    remove_pkg "$pkg"
                fi
            done
        fi
        ;;

    -Q|--query)
        # Check for -i/--info flag (show info)
        if echo "$@" | grep -q '^-i\|--info'; then
            local info_pkg=""
            for arg in "$@"; do
                if [ "${arg#-}" = "$arg" ]; then
                    info_pkg="$arg"
                    break
                fi
            done
            [ -z "$info_pkg" ] && err "Package name required for -Qi"
            show_pkg_info "$info_pkg"
        # Default: List installed packages (-Q)
        else
            query_installed
        fi
        ;;
        
    -c|--clean)
        clean_cache
        ;;
    
    -U|--upgrade)
        self_update "${2:-main}"
        ;;

    *)
        err "Unknown operation '$OPERATION'"
        ;;
esac

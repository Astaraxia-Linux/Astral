#!/bin/sh
# Astral v0.4.9.1 - minimal POSIX package manager for Astaraxia
# Features: Source-only, Auto-recipe fetch, Version locking, Build isolation,
#           added sum

# Set strict execution environment
set -eu

# Global state variables for new features
INSTALL_ROOT="/"    # Feature 2: Installation target directory
FORCE_INSTALL=0     # Feature 3: Force flag (0=off, 1=on)
GLOBAL_PROGRESS_TOTAL=0
GLOBAL_PROGRESS_CURRENT=0
PROGRESS_BAR_SIZE=40

# Directory Layout
RECIPES_DIR=${RECIPES_DIR:-/usr/src/astral/recipes}
CACHE_SRC=${CACHE_SRC:-/var/cache/astral/src}
CACHE_BIN=${CACHE_BIN:-/var/cache/astral/bin}
DB_DIR=${DB_DIR:-/var/lib/astral/db}
REPO_URL=${REPO_URL:-https://izumi-sonoka.github.io/Astral-Repo/}
RECIPE_RAW_URL=${RECIPE_RAW_URL:-https://raw.githubusercontent.com/Izumi-Sonoka/Astral-Repo/main}
INDEX_FILE="$DB_DIR/index"
LOG_DIR=${LOG_DIR:-/var/log/astral}

# --- SELF-UPDATE URLs ---
SELF_UPDATE_URL_MAIN=${SELF_UPDATE_URL_MAIN:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/main/astral}
SELF_UPDATE_URL_CUTTING_EDGE=${SELF_UPDATE_URL_CUTTING_EDGE:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/Testing/astra}
SELF_UPDATE_URL_BLEEDING_EDGE=${SELF_UPDATE_URL_BLEEDING_EDGE:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/Testing/astral}
SELF_UPDATE_PATH=/usr/bin/astral
TMPDIR=${TMPDIR:-/tmp}

mkdir -p "$RECIPES_DIR" "$CACHE_SRC" "$CACHE_BIN" "$DB_DIR" "$LOG_DIR" "$TMPDIR"

err() { printf 'ERROR: %s\n' "$*" >&2; exit 1; }
info() { printf '%s\n' "$*"; }

version="0.4.9.0"

astral_version() {
cat <<EOF
Astral version $version
EOF
    exit 0
}

usage() {
    cat <<USAGE
$version
Usage: astral [global_opts] <command> [pkg...]
Global Options:
  -f, --force             Do force installation/build/removal (e.g., bypass version check, conflict checks).
  --dir <DIR>             Specify root directory for installing packages (defaults to /).

Commands:
  -s, --sync <pkg>        Download recipe (if missing), check deps, and install/upgrade.
  -comp, --compile <pkg>  Build from recipe and install (force build).
  -u, --update            Updates the remote package index (for search).
  --search <pkg>          Searches for package in local recipes and remote index.
  -R, --Remove <pkg>      Remove package (leave deps).
  -r, --RemoveDep <pkg>   Remove package and attempt to remove orphan deps.
  -Cc, --Clean-Cache      Remove recipes for packages that are NOT currently installed.
  -U, --self-update [BR]  Update the astral script itself from GitHub. BR can be 'main' (default) or 'bleeding-edge'.
  -in, --inspect <pkg>    Show recipe files, including package info and build script head.
  -I, --info <pkg>        Show detailed information about an installed or remote package.
  -ua, --upgrade-all      Perform system upgrade (syncs all installed packages).
  -ll, --list-installed   List installed packages.
  -V, --version           Show Astral version.
USAGE
}

# --- CORE UTILITY FUNCTIONS ---

is_pkg_installed() {
    pkg="$1"
    [ -d "$DB_DIR/$pkg" ]
}

astral_progress() {
    local current="$1"
    local total="$2"
    local title="$3"

    [ "$total" -le 0 ] && total=1 # Avoid division by zero

    # Calculate percentage (simple integer arithmetic for POSIX compliance)
    local percent_calc=$((100 * current / total))
    local done_count=$((PROGRESS_BAR_SIZE * current / total))
    local left_count=$((PROGRESS_BAR_SIZE - done_count))

    # Build the bar strings using printf for consistent width
    local fill
    fill=$(printf "%${done_count}s" | tr ' ' '#')
    local empty
    empty=$(printf "%${left_count}s" | tr ' ' '-')

    # Print the bar, using \r to overwrite the line
    printf "\r[${title}] [%s%s] %s%% (%s/%s)" "$fill" "$empty" "$percent_calc" "$current" "$total"
}

# Function to finalize progress and move to a new line
astral_progress_finish() {
    local title="$1"
    # Print a complete 100% bar and then a newline
    printf "\r[${title}] [%s] 100%% (%s/%s)\n" "$(printf "%${PROGRESS_BAR_SIZE}s" | tr ' ' '#')" "$GLOBAL_PROGRESS_TOTAL" "$GLOBAL_PROGRESS_TOTAL"
}

# helper: find recipe path
recipe_path() {
    pkg="$1"
    [ -f "$RECIPES_DIR/$pkg/build" ] && echo "$RECIPES_DIR/$pkg" && return 0
    [ -f "$RECIPES_DIR/$pkg.astral" ] && echo "$RECIPES_DIR/$pkg.astral" && return 0
    return 1
}

# Get installed version (returns "none" if not installed)
get_installed_ver() {
    local pkg="$1"
    if [ -f "$DB_DIR/$pkg/version" ]; then
        cat "$DB_DIR/$pkg/version"
    else
        echo "none"
    fi
}

create_meta() {
    pkg="$1"; ver="$2"; arch="$3"; dest="$4"
    cat > "$dest/.astral-meta" <<M
name=$pkg
version=$ver
arch=$arch
M
}

# FIXED: Replaced non-POSIX \s* with [[:space:]]* and removed the dangerous 'tr -d'
get_pkg_deps() {
    local pkg="$1"
    local depfile="$DB_DIR/$pkg/depends"
    [ -f "$depfile" ] || return 0
    # Use POSIX ERE [[:space:]] to filter comments and empty lines, preserving newlines.
    cat "$depfile" | grep -v '^[[:space:]]*#' | grep -E -v '^[[:space:]]*$'
}

is_pkg_required() {
    local target_pkg="$1"
    for other_pkg_dir in "$DB_DIR"/*; do
        [ -d "$other_pkg_dir" ] || continue
        local other_pkg=$(basename "$other_pkg_dir")
        [ -z "$other_pkg" ] && continue
        [ "$other_pkg" = "$target_pkg" ] && continue
        # get_pkg_deps outputs packages one per line, safe for grep.
        if get_pkg_deps "$other_pkg" | grep -q "^${target_pkg}$"; then
            return 0 # Required
        fi
    done
    return 1 # Not required
}

# --- NETWORKING FUNCTIONS ---

# Fetch recipe files from remote
fetch_remote_recipe() {
    local pkg="$1"
    local local_dir="$RECIPES_DIR/$pkg"
    
    info "Attempting to fetch or refresh recipe for '$pkg' from remote..."
    
    mkdir -p "$local_dir"

    local required_files="version build sources"
    local optional_files="depends package post_install post_remove checksums conflicts info"
    
    local clean_raw_url="${RECIPE_RAW_URL%/}"
    local remote_base="${clean_raw_url}/recipes/$pkg"

    for file in $required_files $optional_files; do
        local url="$remote_base/$file"
        local dest="$local_dir/$file"
        
        # Download silently (-s), fail on 404 (-f).
        if curl -fsSL "$url" -o "$dest" 2>/dev/null; then
            :
        else
            # Check against mandatory files
            if echo "$required_files" | grep -q "$file"; then
                err "Failed to fetch mandatory file '$file' for package '$pkg' from $url"
                rm -rf "$local_dir"
                return 1
            fi
            # If optional file fails, just remove the old local copy
            rm -f "$dest"
        fi
    done
    
    # Make scripts executable
    chmod +x "$local_dir/build" 2>/dev/null || true
    chmod +x "$local_dir/package" 2>/dev/null || true
    # Ensure hooks are executable
    chmod +x "$local_dir/post_install" 2>/dev/null || true
    chmod +x "$local_dir/post_remove" 2>/dev/null || true
    
    info "Recipe for '$pkg' refreshed successfully."
}

# Helper function to download and extract source archives
fetch_and_extract_sources() {
    local pkg="$1"
    local rpath="$2"
    local buildtmp="$3"

    local sources_file="$rpath/sources"
    [ -f "$sources_file" ] || return 0 

    info "Downloading $pkg source..."

    # 1. Count total sources for extraction progress later
    GLOBAL_PROGRESS_TOTAL=$(grep -v '^[[:space:]]*#' "$sources_file" | grep -v '^[[:space:]]*$' | wc -l)
    GLOBAL_PROGRESS_CURRENT=0

    while IFS= read -r url; do
        url=$(echo "$url" | tr -d '[:space:]')
        [ -z "$url" ] && continue
        [ "${url:0:1}" = "#" ] && continue

        local filename=$(basename "$url")
        local dest_file="$buildtmp/$filename"

        info "  -> Downloading $filename"
        # Using -# provides a basic progress bar for curl output to stderr
        if curl -fsSL -# "$url" -o "$dest_file"; then
            :
        else
            err "Failed to download source file from $url"
        fi
    done < "$sources_file"
}

# FIXED: Removed the critical bug where 'tr -d' would break HASH FILENAME parsing.
verify_checksums() {
    local pkg="$1"
    local rpath="$2"
    local buildtmp="$3"
    
    local checksums_file="$rpath/checksums"
    [ -f "$checksums_file" ] || { info "No checksums provided for $pkg. Skipping integrity check."; return 0; }
    
    command -v sha256sum >/dev/null 2>&1 || err "sha256sum command not found. Cannot verify source integrity."

    info "Verifying source integrity using checksums..."
    
    while IFS= read -r line; do
        # Use sed to strip only leading/trailing space for safety, keeping internal spaces (the delimiter).
        line=$(echo "$line" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
        [ -z "$line" ] && continue
        [ "${line:0:1}" = "#" ] && continue
        
        # Expected format: <hash> <filename>
        local expected_hash=$(echo "$line" | awk '{print $1}')
        local filename=$(echo "$line" | awk '{print $2}')

        if [ -z "$expected_hash" ] || [ -z "$filename" ]; then
            err "Checksum file format error for $pkg. Line: '$line'"
        fi

        local file_path="$buildtmp/$filename"

        if [ ! -f "$file_path" ]; then
            err "Checksum error: Source file '$filename' not found in build directory. Cannot verify."
        fi

        # Use sha256sum to check integrity
        local actual_hash=$(sha256sum "$file_path" | awk '{print $1}')
        
        if [ "$actual_hash" != "$expected_hash" ]; then
            err "Checksum mismatch for $filename! Expected $expected_hash, got $actual_hash. Source may be corrupted or compromised. Aborting."
        else
            info "  -> Checksum verified for $filename."
        fi
    done < "$checksums_file"

    # Now that files are verified, extract them
    info "Checksums verified. Extracting sources..."
    local sources_file="$rpath/sources"
    
    while IFS= read -r url; do
        url=$(echo "$url" | tr -d '[:space:]')
        [ -z "$url" ] && continue
        [ "${url:0:1}" = "#" ] && continue
        
        local filename=$(basename "$url")
        local dest_file="$buildtmp/$filename"
        
        info "  -> Extracting $filename"
        # Attempt to extract common archive formats
        case "$filename" in
            *.tar.gz|*.tgz) tar -xf "$dest_file" -C "$buildtmp" || err "Tar extract failed for $filename" ;;
            *.tar.bz2|*.tbz) tar -xf "$dest_file" -C "$buildtmp" || err "Bzip2 extract failed for $filename" ;;
            *.tar.xz|*.txz) tar -xf "$dest_file" -C "$buildtmp" || err "XZ extract failed for $filename" ;;
            *.zip) unzip -q "$dest_file" -d "$buildtmp" || err "Unzip failed for $filename" ;;
            *) info "  -> Warning: Unknown archive type, skipping extraction for $filename." ;;
        esac
        rm "$dest_file" # Clean up the archive file
    done < "$sources_file"
}

# --- COMMAND IMPLEMENTATION FUNCTIONS ---

sync_pkg_recursive() {
    local pkg="$1"
    
    # 1. Ensure we have the recipe (Download/Refresh)
    fetch_remote_recipe "$pkg"

    local recipe_dir="$(recipe_path "$pkg")"
    [ -z "$recipe_dir" ] && err "Recipe for '$pkg' could not be found or downloaded."

    # 2. Handle Dependencies (Recursive)
    local depsf="$recipe_dir/depends"
    if [ -f "$depsf" ]; then
        info "Checking dependencies for $pkg..."
        # Use get_pkg_deps for robust filtering
        get_pkg_deps "$pkg" | while IFS= read -r dep_pkg; do
            # Additional cleanup for safety (removes embedded spaces too)
            dep_pkg=$(echo "$dep_pkg" | tr -d '[:space:]')
            [ -z "$dep_pkg" ] && continue
            
            sync_pkg_recursive "$dep_pkg"
        done
    fi

    # 3. Build/Install
    build_from_recipe "$pkg"
}

build_from_recipe() {
    local pkg="$1"
    local rpath
    rpath=$(recipe_path "$pkg") || err "recipe $pkg not found"
    
    # --- VERSION CHECK LOGIC ---
    local recipe_ver="unknown"
    [ -f "$rpath/version" ] && recipe_ver=$(cat "$rpath/version")
    
    local installed_ver=$(get_installed_ver "$pkg")
    
    if [ "$installed_ver" != "none" ]; then
        if [ "$installed_ver" = "$recipe_ver" ]; then
            if [ "$FORCE_INSTALL" -eq 0 ]; then
                info "Package '$pkg' is already installed at version $installed_ver. Up to date. Skipping build."
                return 0
            else
                info "Package '$pkg' is installed, but force-rebuilding/reinstalling due to -f."
            fi
        else
            info "Upgrading '$pkg' from $installed_ver to $recipe_ver..."
        fi
    else
        info "Installing '$pkg' version $recipe_ver..."
    fi
    # ---------------------------------------------------------------------

    # build environment
    local buildtmp="$TMPDIR/astral-build-$pkg-$$"
    mkdir -p "$buildtmp"

    if [ -d "$rpath" ]; then
        cp -a "$rpath"/* "$buildtmp"/
    else
        cp -a "$rpath" "$buildtmp/recipe.astral"
    fi
    cd "$buildtmp"

    # Set up a trap to ensure cleanup happens even if the script fails unexpectedly
    trap "rm -rf '$buildtmp'" EXIT 

    # 1. Fetch source code
    fetch_and_extract_sources "$pkg" "$rpath" "$buildtmp"
    
    # 2. Verify Checksums and Extract
    verify_checksums "$pkg" "$rpath" "$buildtmp"


    if [ -f "./build" ]; then
        chmod +x ./build || true
        local PKGDIR="$buildtmp/pkg"
        mkdir -p "$PKGDIR"
        
        # ISOLATED BUILD (Using DESTDIR)
        ( DESTDIR="$PKGDIR" ./build ) || err "build failed for $pkg" 
        
        # Make the ./package script optional
        if [ -f "./package" ]; then
            ( DESTDIR="$PKGDIR" PKGDIR="$PKGDIR" ./package ) || err "package() failed for $pkg"
        fi
        
        create_meta "$pkg" "$recipe_ver" "x86_64" "$PKGDIR"
        
        # Record file list
        local new_files
        new_files=$(
            ( cd "$PKGDIR" && find . -mindepth 1 -print ) \
            | sed 's/^\.\///' \
            | grep -v '^\.astral-meta$' \
            || true
        )

        # Install to target root (Transactional extract)
        info "Installing $pkg files to root filesystem ($INSTALL_ROOT)..."
        tar -C "$PKGDIR" -cf - . | tar -C "$INSTALL_ROOT" -xf - || err "failed to extract package files"
        
        # Record database
        local pkgdir="$DB_DIR/$pkg"
        mkdir -p "$pkgdir"
        printf '%s\n' "$recipe_ver" > "$pkgdir/version"
        printf '%s\n' "$new_files" > "$pkgdir/files"
        
        if [ -f "$buildtmp/depends" ]; then
            cp "$buildtmp/depends" "$pkgdir/depends"
        fi
        
        # --- POST-INSTALL HOOK ---
        if [ -f "$buildtmp/post_install" ]; then
            info "Running post_install hook for $pkg..."
            # Execute the hook script
            ( DESTDIR="$INSTALL_ROOT" PKGDIR="$PKGDIR" "$buildtmp/post_install" ) || info "Warning: post_install hook failed for $pkg. Continuing."
        fi
        # --- END HOOK ---
        
        info "Successfully installed $pkg ($recipe_ver)."
    else
        err "Recipe $pkg has no build script"
    fi
    
    # Cleanup will happen via the trap, but we can reset it if we reach here cleanly.
    trap - EXIT
    rm -rf "$buildtmp" # Manual cleanup if trap wasn't triggered
}

update_repo() {
    info "Updating package database index..."
    local INDEX_URL="${REPO_URL}astral.index"
    if curl -fsSL "$INDEX_URL" -o "$INDEX_FILE"; then
        info "Database updated successfully."
    else
        err "Failed to download index file from "$INDEX_URL"."
        return 1
    fi
}

search_pkg() {
    local query="$1"
    info "Searching for package '$query'..."
    info "--- Local Recipes ---"
    local found_local=0
    for r in "$RECIPES_DIR"/*; do
        if [ -d "$r" ]; then
            local pkg_name=$(basename "$r")
            if echo "$pkg_name" | grep -iq "$query"; then
                local ver="unknown"
                [ -f "$r/version" ] && ver=$(cat "$r/version")
                printf "L: %-20s (v%s)\n" "$pkg_name" "$ver"
                found_local=1
            fi
        fi
    done
    [ "$found_local" -eq 0 ] && info "No local recipes found."

    info "--- Remote Index ---"
    [ -f "$INDEX_FILE" ] || { info "Remote index not found. Run 'astral -u'."; return 0; }
    local found_remote=0
    while IFS= read -r line; do
        local pkg_name=$(echo "$line" | awk '{print $1}')
        local pkg_ver=$(echo "$line" | awk '{print $2}')
        if echo "$pkg_name" | grep -iq "$query"; then
            printf "R: %-20s (v%s)\n" "$pkg_name" "$pkg_ver"
            found_remote=1
        fi
    done < "$INDEX_FILE"
    [ "$found_remote" -eq 0 ] && info "No remote packages found."
}

# FIXED: Dependency/Conflict list parsing now uses get_pkg_deps for robustness.
show_pkg_info() {
    local pkg="$1"
    local rpath="$(recipe_path "$pkg")"
    local recipe_exists=1
    [ -z "$rpath" ] && recipe_exists=0
    
    info "--- Package Information: $pkg ---"
    
    # Installed Info
    local installed_ver=$(get_installed_ver "$pkg")
    printf "Installed Version: %s\n" "$installed_ver"
    if [ "$installed_ver" != "none" ]; then
        local installed_date="N/A"
        [ -f "$DB_DIR/$pkg/files" ] && installed_date=$(stat -c "%y" "$DB_DIR/$pkg/files" 2>/dev/null || echo "N/A")
        printf "Installed Path:    %s\n" "$DB_DIR/$pkg"
        printf "Installation Date: %s\n" "$installed_date"
        printf "Installed Files:   %s files\n" "$(wc -l < "$DB_DIR/$pkg/files" 2>/dev/null || echo 0)"
    fi
    
    # Recipe Info
    if [ "$recipe_exists" -eq 1 ]; then
        local recipe_ver=$(cat "$rpath/version" 2>/dev/null || echo "unknown")
        printf "\nRecipe Found:      Yes\n"
        printf "Recipe Version:    %s\n" "$recipe_ver"
        printf "Recipe Path:       %s\n" "$rpath"

        local deps_list="None"
        local deps_count=0
        local conflicts_list="None"
        local conflicts_count=0

        # Dependency Info
        if [ -f "$rpath/depends" ]; then
            local filtered_deps=$(get_pkg_deps "$pkg")
            deps_list=$(echo "$filtered_deps" | tr '\n' ' ')
            deps_count=$(echo "$filtered_deps" | wc -l)
        fi
        printf "Dependencies (%s): %s\n" "$deps_count" "$deps_list"
        
        # Conflicts Info
        if [ -f "$rpath/conflicts" ]; then
            local filtered_conflicts=$(cat "$rpath/conflicts" | grep -v '^[[:space:]]*#' | grep -E -v '^[[:space:]]*$')
            conflicts_list=$(echo "$filtered_conflicts" | tr '\n' ' ')
            conflicts_count=$(echo "$filtered_conflicts" | wc -l)
        fi
        printf "Conflicts (%s):     %s\n" "$conflicts_count" "$conflicts_list"
        
        printf "Build Script:      %s\n" "$( [ -f "$rpath/build" ] && echo "Yes" || echo "No" )"
        printf "Package Script:    %s\n" "$( [ -f "$rpath/package" ] && echo "Yes" || echo "No" )"
        printf "Checksums:         %s\n" "$( [ -f "$rpath/checksums" ] && echo "Yes" || echo "No" )"
    else
        printf "\nRecipe Found:      No (Run 'astral -s %s' to fetch)\n" "$pkg"
    fi
}

upgrade_all() {
    info "Starting full system upgrade (syncing all installed packages)..."
    local count=0
    local success_count=0
    
    # 1. Update index first
    update_repo || info "Warning: Could not update remote index. Continuing with local recipes."

    info "\nChecking all installed packages for updates..."

    for pkg_dir in "$DB_DIR"/*; do
        if [ -d "$pkg_dir" ]; then
            local pkg=$(basename "$pkg_dir")
            info "\n>>> Checking $pkg <<<"
            # Note: sync_pkg_recursive handles the version check/skip internally
            if sync_pkg_recursive "$pkg"; then
                success_count=$((success_count + 1))
            else
                info "Warning: Failed to sync $pkg. Check logs."
            fi
            count=$((count + 1))
        fi
    done
    info "\nUpgrade process finished. Checked $count installed packages. $success_count updated/verified."
}


self_update() {
    # 1. Ensure TMPDIR is set, defaulting to /tmp
    TMPDIR="${TMPDIR:-/tmp}"
    
    # 2. Use mktemp for a secure temporary file name
    # The -t flag prepends $TMPDIR/ if not already, and the 'astral-new.XXXXXX' pattern is helpful.
    local tmp_file
    tmp_file=$(mktemp "$TMPDIR/astral-new.XXXXXX")
    if [ $? -ne 0 ]; then
        err "Failed to create secure temporary file using mktemp."
        return 1
    fi

    # Ensure the temporary file is cleaned up on exit (success or failure)
    trap 'rm -f "$tmp_file"' EXIT

    local branch="${1:-main}"
    local update_url=""
    
    case "$branch" in
        main)
            update_url="$SELF_UPDATE_URL_MAIN"
            info "Starting astral self-update from 'main' branch ($update_url)..."
            ;;
        cutting-edge)
            update_url="$SELF_UPDATE_URL_CUTTING_EDGE"
            info "Starting astral self-update from 'cutting-edge' branch ($update_url)..."
            ;;
        bleeding-edge)
            update_url="$SELF_UPDATE_URL_BLEEDING_EDGE"
            info "Starting astral self-update from 'bleeding-edge' branch ($update_url)..."
            ;;
        *)
            err "Unknown update branch/channel '$branch'. Please use 'main' (default), 'cutting-edge', or 'bleeding-edge'."
            # FIX: Added return 1 here to stop execution on unknown branch
            return 1 
            ;;
    esac

    # Check for curl before attempting download
    command -v curl >/dev/null 2>&1 || { err "curl not found."; return 1; }

    # Use the selected update_url
    if [ -z "$update_url" ]; then
        err "Internal error: Update URL is empty."
        return 1
    fi

    if ! curl -fsSL "$update_url" -o "$tmp_file"; then
        err "Failed to download new astral script from $update_url."
        # The trap handles cleanup, no need for rm -f here
        return 1
    fi
    
    # Check for shebang robustness: requires a leading '#!' and then non-space characters (or only spaces)
    if ! head -n 1 "$tmp_file" | grep -qE '^#!([[:space:]]*/bin/sh|[[:space:]]*/usr/bin/env)'; then
        err "Downloaded file invalid (missing shebang or invalid content)."
        return 1
    fi
    
    # Check if the downloaded file has any content (e.g., if the URL returned a 404 page)
    if [ ! -s "$tmp_file" ]; then
        err "Downloaded file is empty or too small. Download failed."
        return 1
    fi

    chmod +x "$tmp_file"
    if mv -f "$tmp_file" "$SELF_UPDATE_PATH"; then
        info "Self-update successful! New script installed to $SELF_UPDATE_PATH."
        # Crucial: Disable the trap's cleanup since the file has been moved
        trap - EXIT 
        # Relaunch the script if necessary (common in self-updaters, but not included here)
    else
        err "Failed to replace $SELF_UPDATE_PATH. Check permissions."
        return 1
    fi
}

remove_pkg() {
    pkg="$1"
    pkgdir="$DB_DIR/$pkg"
    [ -d "$pkgdir" ] || err "package $pkg not installed"

    # Set up a trap to clean up the temporary directory list file
    local dirs_file="$TMPDIR/astral-dirs-$pkg-$$"
    trap "rm -f '$dirs_file'" EXIT 

    # --- PRE-REMOVE HOOK ---
    local rpath=$(recipe_path "$pkg")
    if [ -f "$rpath/post_remove" ]; then
        info "Running post_remove hook for $pkg..."
        if [ "$FORCE_INSTALL" -eq 0 ]; then
            ( "$rpath/post_remove" ) || info "Warning: post_remove hook failed for $pkg, continuing removal."
        else
            ( "$rpath/post_remove" ) || info "Force mode: post_remove hook failed for $pkg. Continuing."
        fi
    fi
    # --- END HOOK ---

    info "Removing $pkg from $INSTALL_ROOT"
    
    # 1. Read files list, remove files, and collect directories in the temporary file
    while IFS= read -r f; do
        [ -z "$f" ] && continue
        
        # Build the full path using the custom installation root
        local fullpath="$INSTALL_ROOT/$f"
        
        if [ -d "$fullpath" ]; then
            # Directory found. Add to the temporary list.
            printf "%s\n" "$f" >> "$dirs_file"
        elif [ -e "$fullpath" ]; then
            # File or symlink. Remove it immediately.
            info "  -> Deleting file: $f"
            rm -f "$fullpath"
        else
            # Path doesn't exist, skip it.
            : 
        fi
    done < "$pkgdir/files"
    
    # 2. Process collected directories (deepest first, guaranteed by 'sort -r')
    if [ -f "$dirs_file" ]; then
        info "Attempting to clean up empty directories installed by $pkg..."
        # Sort reverse alphabetically to approximate deepest-first removal.
        sort -r "$dirs_file" | while IFS= read -r d; do
            [ -z "$d" ] && continue
            # Build the full directory path using the custom installation root
            local dir_path="$INSTALL_ROOT/$d"
            # rmdir will fail safely on non-empty directories
            if rmdir "$dir_path" 2>/dev/null; then
                info "  -> Deleted empty directory: $dir_path"
            fi
        done
        rm -f "$dirs_file" # Explicit cleanup
    fi
    
    # Reset trap before final deletion
    trap - EXIT
    rm -rf "$pkgdir"
    info "Removed $pkg successfully from database."
}

removedep_pkg() {
    pkg="$1"
    remove_pkg "$pkg"
    info "Scanning for orphaned dependencies..."
    while true; do
        found_orphan=0
        for dep_dir in "$DB_DIR"/*; do
            [ -d "$dep_dir" ] || continue
            dep_name=$(basename "$dep_dir")
            if ! is_pkg_required "$dep_name"; then
                info "Removing orphan dependency: $dep_name"
                remove_pkg "$dep_name"
                found_orphan=1
                break
            fi 
        done
        [ "$found_orphan" -eq 0 ] && break
    done
}

clean_cache() {
    info "Starting recipe cache cleanup in $RECIPES_DIR..."
    local cleaned_count=0
    for recipe_dir in "$RECIPES_DIR"/*; do
        if [ ! -d "$recipe_dir" ]; then
            continue
        fi
        local pkg=$(basename "$recipe_dir")
        
        if is_pkg_installed "$pkg"; then
            info "Recipe for '$pkg' is installed. Skipping."
        else
            info "Recipe for '$pkg' is NOT installed. Removing cache files..."
            rm -rf "$recipe_dir"
            cleaned_count=$((cleaned_count + 1))
        fi
    done
    info "Cache cleanup complete. Removed $cleaned_count orphaned recipe(s)."
}

list_installed() {
    for d in "$DB_DIR"/*; do
        [ -d "$d" ] || continue
        printf '%s %s\n' "$(basename "$d")" "$(cat "$d/version" 2>/dev/null || echo unknown)"
    done
}

# CLI dispatch
if [ $# -lt 1 ]; then usage; exit 1; fi

# Feature 1: Root Check
if ! echo "$@" | grep -q '\(--search\|--inspect\|--info\|--list-installed\|--version\|-V\|-u\|--update\)'; then
    if [ "$(id -u)" -ne 0 ]; then 
        err "Astral must be run as root (UID 0) to perform installation, removal, or self-update operations."
    fi
fi

# --- Global Option Parsing ---
while true; do
    case "$1" in
        -f|--force)
            FORCE_INSTALL=1
            info "Force mode activated."
            shift
            ;;
        --dir)
            [ $# -lt 2 ] && err "Missing argument for $1"
            INSTALL_ROOT="$2"
            shift 2
            ;;
        --dir=*)
            INSTALL_ROOT="${1#*=}"
            shift
            ;;
        -V|--version)
            astral_version
            ;;
        --) # End of options
            shift
            break
            ;;
        -*) # Unknown option or command (or a command itself)
            break
            ;;
        *) # Command (or package name)
            break
            ;;
    esac
done

# Check if a command is left
if [ $# -lt 1 ]; then usage; exit 1; fi

# Ensure INSTALL_ROOT has no trailing slash (unless it is just "/")
if [ "$INSTALL_ROOT" != "/" ]; then
    INSTALL_ROOT="${INSTALL_ROOT%/}"
    info "Installation root set to: $INSTALL_ROOT"
fi

# Now $1 is the command, and $2, $3... are its arguments.

case "$1" in
  -s|--sync)
    [ $# -gt 1 ] || err "pkg required"
    sync_pkg_recursive "$2"
    ;;
  -comp|--compile)
    [ $# -gt 1 ] || err "pkg required"
    build_from_recipe "$2"
    ;;
  -u|--update)
    update_repo
    ;;
  --search)
    [ $# -gt 1 ] || err "package name required"
    search_pkg "$2"
    ;;
  -R|--Remove)
    [ $# -gt 1 ] || err "pkg required"
    remove_pkg "$2"
    ;;
  -r|--RemoveDep)
    [ $# -gt 1 ] || err "pkg required"
    removedep_pkg "$2"
    ;;
  -Cc|--Clean-Cache)
    clean_cache
    ;;
  -U|--self-update)
    self_update "${2:-main}"
    ;;
  --info|-I)
    [ $# -gt 1 ] || err "pkg required"
    show_pkg_info "$2"
    ;;
  --upgrade-all|-ua)
    upgrade_all
    ;;
  --inspect|-ins)
    [ $# -gt 1 ] || err "pkg required"
    r=$(recipe_path "$2") || err "recipe not found"
    info "--- Files in Recipe Directory: $r ---"
    if [ -d "$r" ]; then
      ls -la "$r"
      # Display info file content
      [ -f "$r/info" ] && { info "\n--- PACKAGE INFO ($2) ---\n"; cat "$r/info"; }
      # Display build script head
      [ -f "$r/build" ] && { info "\n--- BUILD SCRIPT HEAD ($2) ---\n"; sed -n '1,200p' "$r/build"; }
    else
      info "--- Single Recipe File Content ($2) ---\n"
      sed -n '1,200p' "$r"
    fi
    ;;
  --list-installed|-ll)
    list_installed
    ;;
  *)
    echo "Error: Unknown command or option '$1'" >&2
    usage
    exit 1
    ;;
esac

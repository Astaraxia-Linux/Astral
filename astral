#!/bin/sh
# Astral v0.7.0.0 Main - minimal POSIX package manager for Astaraxia
# Modified: added Astral.conf for make!
# V: X- Major . X - Minor . X - Patches . X - hotfixes

# Set strict execution environment, meow~
set -eu

# Global state variables
INSTALL_ROOT="/"    # Installation target directory
FORCE_BUILD=0
DRY_RUN=0
VISITED_PACKAGES=""

# Locate where tf is astral
SCRIPT_PATH="$(readlink -f "$0")"
SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"

# Directory Layout
RECIPES_DIR=${RECIPES_DIR:-/usr/src/astral/recipes}
CACHE_SRC=${CACHE_SRC:-/var/cache/astral/src}
CACHE_BIN=${CACHE_BIN:-/var/cache/astral/bin}
DB_DIR=${DB_DIR:-/var/lib/astral/db}
INDEX_FILE="$DB_DIR/index"
LOG_DIR=${LOG_DIR:-/var/log/astral}

# --- REPOS ---
REPO_URL=${REPO_URL:-https://izumi-sonoka.github.io/AOHARU/}
RECIPE_RAW_URL=${RECIPE_RAW_URL:-https://raw.githubusercontent.com/Izumi-Sonoka/AOHARU/main}
USER_REPO_URL=${USER_REPO_URL:-https://codeberg.org/Izumi/ASURA/raw/branch/main}
USER_RECIPE_RAW_URL=${USER_RECIPE_RAW_URL:-$USER_REPO_URL/recipes}

# --- SELF-UPDATE URLs ---
SELF_UPDATE_URL_MAIN=${SELF_UPDATE_URL_MAIN:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/main/astral}
SELF_UPDATE_URL_CUTTING_EDGE=${SELF_UPDATE_URL_CUTTING_EDGE:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/Testing/astra}
SELF_UPDATE_URL_BLEEDING_EDGE=${SELF_UPDATE_URL_BLEEDING_EDGE:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/Testing/astral}
SELF_UPDATE_PATH=/usr/bin/astral
TMPDIR=${TMPDIR:-/tmp}

# --- INDEKS --- Malay cuz why not
INDEX_FILE_AOHARU="$DB_DIR/index_aoharu"
INDEX_FILE_ASURA="$DB_DIR/index_asura"

mkdir -p "$RECIPES_DIR" "$CACHE_SRC" "$CACHE_BIN" "$DB_DIR" "$LOG_DIR" "$TMPDIR"

err() { printf 'ERROR: %s\n' "$*" >&2; exit 1; }
info() { printf '%s\n' "$*"; }

version="0.7.0.0 Main"

# --- CONFIG SYSTEM () ---
CONFIG_FILE=${CONFIG_FILE:-/etc/astral/make.conf}
USE_FLAGS=""
CFLAGS="-O2 -pipe"
CXXFLAGS=""
LDFLAGS=""
MAKEFLAGS="-j1"
CCACHE_ENABLED="no"
FEATURES=""
BINPKG_ENABLED="no"
CACHE_BIN=${CACHE_BIN:-/var/cache/astral/bin}

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        . "$CONFIG_FILE"
    fi
    
    [ -z "$CXXFLAGS" ] && CXXFLAGS="$CFLAGS"
    
    if [ "$CCACHE_ENABLED" = "yes" ]; then
        if command -v ccache >/dev/null 2>&1; then
            export CC="ccache gcc"
            export CXX="ccache g++"
            info "ccache enabled"
        fi
    fi
    
    export CFLAGS CXXFLAGS LDFLAGS MAKEFLAGS
}

has_feature() {
    feature="$1"
    case " $FEATURES " in
        *" $feature "*) return 0 ;;
        *) return 1 ;;
    esac
}
ensure_default_config() {
    if [ ! -f "$CONFIG_FILE" ]; then
        mkdir -p "$(dirname "$CONFIG_FILE")"
        cat > "$CONFIG_FILE" <<EOF
# astral configuration

USE_FLAGS=""
CFLAGS="-O2 -pipe"
CXXFLAGS=""
LDFLAGS=""
MAKEFLAGS="-j1"
CCACHE_ENABLED="no"
FEATURES=""
BINPKG_ENABLED="no"
EOF
    fi
}

check_script_safety() {
    script_file="$1"
    pkg_name="$2"
    
    [ ! -f "$script_file" ] && return 0
    
    info "Running safety checks on '$pkg_name'..."
    
    # Blocks: rm -rf $PKGDIR/ or rm -rf $DESTDIR/
    if grep -qE '\$(\{)?(PKGDIR|DESTDIR)(\})?[[:space:]]*/[[:space:]]*$' "$script_file" 2>/dev/null; then
        err "SECURITY: Refusing to run '$pkg_name' - unsafe PKGDIR usage detected (expands to /)"
    fi
    
    # Dangerous command patterns
    if grep -qE 'rm[[:space:]]+-[rf][rf][[:space:]]+(\$(\{)?(PKGDIR|DESTDIR)(\})?)?/[[:space:]]*$' "$script_file" 2>/dev/null; then
        err "SECURITY: Refusing to run '$pkg_name' - dangerous rm -rf / detected"
    fi
    
    if grep -qE 'rm[[:space:]]+-[rf][rf][[:space:]]+/($|[^a-zA-Z])' "$script_file" 2>/dev/null; then
        err "SECURITY: Refusing to run '$pkg_name' - rm -rf on root paths detected"
    fi
    
    # Block disk destruction commands
    if grep -qE '>[[:space:]]*/dev/sd|dd[[:space:]]+.*of=/dev/[sh]d|mkfs\.|wipefs' "$script_file" 2>/dev/null; then
        err "SECURITY: Refusing to run '$pkg_name' - disk destruction command detected"
    fi
    
    # Block fork bombs
    if grep -qE ':[[:space:]]*\(\)[[:space:]]*\{[[:space:]]*:[[:space:]]*\|:[[:space:]]*&[[:space:]]*\}' "$script_file" 2>/dev/null; then
        err "SECURITY: Refusing to run '$pkg_name' - fork bomb detected"
    fi
    
    # Block recursive chmod 777
    if grep -qE 'chmod[[:space:]]+-R[[:space:]]+777[[:space:]]+/' "$script_file" 2>/dev/null; then
        err "SECURITY: Refusing to run '$pkg_name' - recursive chmod 777 on root detected"
    fi
    
    # Block curl|sh and wget|sh
    if grep -qE '(curl|wget).*\|[[:space:]]*(ba)?sh' "$script_file" 2>/dev/null; then
        err "SECURITY: Refusing to run '$pkg_name' - curl/wget piped to shell detected"
    fi
    
    # Warn about eval (not blocked, just warned)
    if grep -qE '^[[:space:]]*eval[[:space:]]' "$script_file" 2>/dev/null; then
        warn "Script '$pkg_name' contains 'eval' - review carefully before running"
    fi
    
    info "✓ Safety check passed for '$pkg_name'"
}

# --- FILE OWNERSHIP DATABASE ---
get_file_owner() {
    file="$1"
    file_normalized=$(printf '%s' "$file" | sed 's|^/||')

    # Search all package databases for file ownership
    for pkgdir in "$DB_DIR"/*/* "$DB_DIR"/*; do
        [ -d "$pkgdir" ] || continue
        [ -f "$pkgdir/files" ] || continue

        if grep -qxF "$file_normalized" "$pkgdir/files" 2>/dev/null; then
            pkg_path=$(printf '%s' "$pkgdir" | sed "s|^${DB_DIR}/||")
            printf '%s' "$pkg_path"
            return 0
        fi
    done

    return 1
}

check_file_conflicts() {
    pkg="$1"
    pkgdir="$2"
    force="$3"

    [ "$DRY_RUN" -eq 1 ] && info "[DRY-RUN] Checking for file conflicts..."
    [ "$DRY_RUN" -eq 0 ] && info "Checking for file conflicts..."

    [ ! -d "$pkgdir" ] && return 0

    conflicts=""
    conflict_count=0

    ( cd "$pkgdir" && find . -type f -o -type l ) | sed 's|^\./||' | while IFS= read -r file; do
        [ -z "$file" ] && continue
        [ "$file" = ".astral-meta" ] && continue

        target_path="$INSTALL_ROOT/$file"

        # Skip if file doesn't exist yet
        [ ! -e "$target_path" ] && [ ! -L "$target_path" ] && continue

        # Check who owns this file
        owner=$(get_file_owner "$file") || owner=""

        if [ -n "$owner" ]; then
            owner_name=$(basename "$owner")
            if [ "$owner_name" != "$pkg" ]; then
                conflict_count=$((conflict_count + 1))
                warn "  ✗ CONFLICT: $file (owned by $owner)"
                printf '%s|%s\n' "$file" "$owner"
            fi
        else
            # File exists but not tracked
            conflict_count=$((conflict_count + 1))
            warn "  ✗ CONFLICT: $file (untracked file on system)"
            printf '%s|%s\n' "$file" "UNTRACKED"
        fi
    done > "$TMPDIR/conflicts.$$"

    conflict_count=$(wc -l < "$TMPDIR/conflicts.$$" 2>/dev/null || echo 0)

    if [ "$conflict_count" -gt 0 ]; then
        if [ "$force" -eq 0 ]; then
            cat "$TMPDIR/conflicts.$$" >&2
            rm -f "$TMPDIR/conflicts.$$"
            err "Found $conflict_count file conflict(s). Use -f/--force to override."
        else
            warn "Overriding $conflict_count file conflict(s) due to --force"
            cat "$TMPDIR/conflicts.$$" >&2
        fi
    else
        info "  ✓ No file conflicts detected"
    fi

    rm -f "$TMPDIR/conflicts.$$"
}

# --- VERSION COMPARISON ---
version_compare() {
    ver1="$1"
    op="$2"
    ver2="$3"
    
    # Handle equal versions first
    if [ "$ver1" = "$ver2" ]; then
        case "$op" in
            "="|">="|"<=") return 0 ;;
            *) return 1 ;;
        esac
    fi
    
    # Convert versions to comparable integers
    # Example: 2.38.1 -> 002038001
    v1_num=$(printf '%s' "$ver1" | awk -F. '{printf "%03d%03d%03d\n", $1, $2, $3}')
    v2_num=$(printf '%s' "$ver2" | awk -F. '{printf "%03d%03d%03d\n", $1, $2, $3}')
    
    case "$op" in
        ">")  [ "$v1_num" -gt "$v2_num" ] && return 0 || return 1 ;;
        ">=") [ "$v1_num" -ge "$v2_num" ] && return 0 || return 1 ;;
        "<")  [ "$v1_num" -lt "$v2_num" ] && return 0 || return 1 ;;
        "<=") [ "$v1_num" -le "$v2_num" ] && return 0 || return 1 ;;
        "=")  [ "$v1_num" -eq "$v2_num" ] && return 0 || return 1 ;;
        *)    return 1 ;;
    esac
}

check_versioned_deps() {
    pkg="$1"
    
    deps_file=""
    pkg_path=$(resolve_installed_path "$pkg") 2>/dev/null || pkg_path="$pkg"
    deps_file="$DB_DIR/$pkg_path/depends"
    
    if [ ! -f "$deps_file" ]; then
        rpath=$(recipe_path "$pkg") 2>/dev/null || rpath=""
        [ -n "$rpath" ] && deps_file="$rpath/depends"
    fi
    
    [ ! -f "$deps_file" ] && return 0
    
    info "Checking versioned dependencies for $pkg..."
    
    while IFS= read -r depline; do
        depline=$(printf '%s' "$depline" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
        [ -z "$depline" ] && continue
        case "$depline" in \#*) continue ;; esac
        
        # Parse: package_name [>=/<=/>/<] version
        dep_pkg=$(printf '%s' "$depline" | awk '{print $1}')
        dep_op=$(printf '%s' "$depline" | awk '{print $2}')
        dep_ver=$(printf '%s' "$depline" | awk '{print $3}')
        
        # No version constraint
        if [ -z "$dep_op" ] || [ -z "$dep_ver" ]; then
            continue
        fi
        
        # Check if installed
        if ! is_pkg_installed "$dep_pkg"; then
            warn "  ✗ $dep_pkg $dep_op $dep_ver (NOT INSTALLED)"
            return 1
        fi
        
        # Get version
        installed_ver=$(get_installed_ver "$dep_pkg")
        [ "$installed_ver" = "none" ] && installed_ver="0.0.0"
        
        # Compare
        if version_compare "$installed_ver" "$dep_op" "$dep_ver"; then
            info "  ✓ $dep_pkg $dep_op $dep_ver (installed: $installed_ver)"
        else
            warn "  ✗ $dep_pkg $dep_op $dep_ver (installed: $installed_ver) - VERSION MISMATCH"
            return 1
        fi
    done < "$deps_file"
    
    return 0
}

astral_version() {
cat <<EOF
┌──────────────────────┐
│ Astral: $version │
└──────────────────────┘
EOF
    exit 0
}

usage() {
    cat <<USAGE
┌──────────────────────┐
│ Astral: $version │
└──────────────────────┘
┌───────────────────────────────────┐
│ Astral File is in $SCRIPT_PATH │
└───────────────────────────────────┘
┌────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐
│ Usage: astral [global_opts] <command> [pkg...]                                                                         │
│                                                                                                                        │
│ Global Options:                                                                                                        │
│   --dir <DIR>             Specify root directory for installing packages (defaults to /).                              │
│   -f, --force             Force operation (override conflicts) - PER COMMAND, not global.                              │
│   -n, --dry-run           Dry-run mode: show what would happen without doing it.                                       │
│                                                                                                                        │
│ Commands:                                                                                                              │
│   -S, --Sync <pkg>        Download recipe from AOHARU (if missing), check deps, and install/upgrade.                   │
│   -Sa, --Sync-Asura <pkg> Download recipe from ASURA (if missing), check deps, and install/upgrade.                    │
│   -C, --Compile <pkg>     Build from recipe and install (force build).                                                 │
│   -u, --Update [REPO]     Updates the remote package index (for search). Repo can only be 'aoharu' (default) or asura. │
│   -S, --search <pkg>      Searches for package in local recipes and remote index.                                      │
│   -R, --Remove <pkg>      Remove package (leave deps).                                                                 │
│   -r, --RemoveDep <pkg>   Remove package and attempt to remove orphan deps (safe, hopefully).                          │
│   -Cc, --Clean-Cache      Remove recipes for packages that are NOT currently installed.                                │
│   -U, --self-update [BR]  Update the astral script itself from GitHub. BR can be 'main' (default) or 'bleeding-edge'.  │
│   -Ins, --Inspect <pkg>   Show recipe files, including package info and build script head.                             │
│   -I, --info <pkg>        Show detailed information about an installed or remote package.                              │
│   -UA, --Upgrade-All      Perform system upgrade (syncs all installed packages).                                       │
│   -D,   --Deps <pkg>      Show dependency tree for package.                                                            │
│   -Dc,  --DepCheck        Check system for broken dependencies.                                                        │
│   --config                Show current configuration.                                                                  │
│   -ll, --List-Installed   List installed packages.                                                                     │
│   -V, --Version           Show Astral version.                                                                         │
└────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘
USAGE
}

# --- CORE UTILITY FUNCTIONS ---

is_pkg_installed() {
    pkg="$1"
    [ -d "$DB_DIR/$pkg" ] || [ -n "$(find "$DB_DIR" -type d -name "$pkg" -maxdepth 2 2>/dev/null)" ]
}

resolve_installed_path() {
    requested_pkg="$1"

    if [ -d "$DB_DIR/$requested_pkg" ]; then
        printf '%s\n' "$requested_pkg"
        return 0
    fi

    found_path=$(find "$DB_DIR" -type d -name "$requested_pkg" -maxdepth 2 2>/dev/null | head -n 1 || true)
    if [ -n "$found_path" ]; then
        printf '%s\n' "$(printf '%s' "$found_path" | sed "s|^${DB_DIR}/||")"
        return 0
    fi

    return 1
}

# helper: find recipe path - search subdirectories
recipe_path() {
    pkg="$1"

    if [ -d "$RECIPES_DIR/$pkg" ]; then
        printf '%s\n' "$RECIPES_DIR/$pkg"
        return 0
    fi

    found_path=$(find "$RECIPES_DIR" -type d -name "$pkg" -maxdepth 2 2>/dev/null | head -n 1 || true)
    if [ -n "$found_path" ] && [ -d "$found_path" ]; then
        printf '%s\n' "$found_path"
        return 0
    fi

    return 1
}

# Get installed version (returns "none" if not installed)
get_installed_ver() {
    requested_pkg="$1"
    pkg_path=$(resolve_installed_path "$requested_pkg") || { printf 'none\n'; return 0; }

    if [ -f "$DB_DIR/$pkg_path/version" ]; then
        cat "$DB_DIR/$pkg_path/version"
    else
        printf 'none\n'
    fi
}

create_meta() {
    pkg="$1"; ver="$2"; arch="$3"; dest="$4"
    cat > "$dest/.astral-meta" <<M
name=$pkg
version=$ver
arch=$arch
M
}

# Extracts dependency names from the depends file, filtering comments and empty lines.
get_pkg_deps() {
    pkg="$1"
    depfile=""

    pkg_path=$(resolve_installed_path "$pkg") 2>/dev/null || pkg_path="$pkg"
    depfile="$DB_DIR/$pkg_path/depends"

    if [ ! -f "$depfile" ]; then
        rpath=$(recipe_path "$pkg") 2>/dev/null || rpath=""
        [ -n "${rpath}" ] && depfile="$rpath/depends"
    fi

    [ -f "$depfile" ] || return 0

    # Return only package names (first field) for dependency resolution
    grep -v '^[[:space:]]*#' "$depfile" | grep -E -v '^[[:space:]]*$' | awk '{print $1}' || true
}

# Checks if a package (by DB relative path) is required by any other installed package.
is_pkg_required() {
    target_pkg_path="$1"
    target_pkg=$(basename "$target_pkg_path")

    for other_pkg_dir in "$DB_DIR"/*/* "$DB_DIR"/*; do
        [ -d "$other_pkg_dir" ] || continue
        other_pkg_path=$(printf '%s' "$other_pkg_dir" | sed "s|^${DB_DIR}/||")
        [ "$other_pkg_path" = "$target_pkg_path" ] && continue

        other_deps=$(get_pkg_deps "$other_pkg_path" 2>/dev/null || true)
        if printf '%s\n' "$other_deps" | grep -qE "^${target_pkg_path}$|^${target_pkg}$"; then
            return 0
        fi
    done

    return 1
}

# --- HOST DEPENDENCY DETECTION ---
# Returns 0 if dependency is satisfied by host (binary in PATH or shared lib)
check_host_dependency() {
    dep="$1"

    # If looks like a common binary name, check PATH
    if command -v "$dep" >/dev/null 2>&1; then
        return 0
    fi

    # If dep looks like a library (lib*.so or ending with .so), check ldconfig and common lib dirs
    # Normalize: if dep contains .so or lib prefix
    case "$dep" in
        lib*.so*|*.so*)
            # try ldconfig -p if available
            if command -v ldconfig >/dev/null 2>&1; then
                if ldconfig -p 2>/dev/null | grep -q "$(printf '%s' "$dep" | sed 's/[]\/$*.^[]/\\&/g')"; then
                    return 0
                fi
            fi
            # fallback to scanning /lib /usr/lib /usr/local/lib (and multiarch)
            for p in /lib /usr/lib /usr/local/lib /lib64 /usr/local/lib64 /usr/lib64; do
                if ls "$p" 2>/dev/null | grep -q "$(printf '%s' "$dep" | sed 's/[]\/$*.^[]/\\&/g')"; then
                    return 0
                fi
            done
            ;;
        *)
            # Not obviously a .so file; additionally check for lib<name>.so patterns
            libname="lib${dep}.so"
            if command -v ldconfig >/dev/null 2>&1; then
                if ldconfig -p 2>/dev/null | grep -q "$libname"; then
                    return 0
                fi
            fi
            for p in /lib /usr/lib /usr/local/lib /lib64 /usr/lib64 /usr/local/lib64; do
                if ls "$p" 2>/dev/null | grep -q "^${libname}" ; then
                    return 0
                fi
            done
            ;;
    esac

    return 1
}

# --- NETWORKING / RECIPE FUNCTIONS ---

fetch_remote_recipe() {
    pkg="$1"
    local_dir="$RECIPES_DIR/$pkg"

    info "Attempting to fetch or refresh recipe for '$pkg' from remote..."

    existing_rpath=$(recipe_path "$pkg") 2>/dev/null || existing_rpath=""

    if [ -n "$existing_rpath" ]; then
        category_pkg=$(printf '%s' "$existing_rpath" | sed "s|^${RECIPES_DIR}/||")
        local_dir="$RECIPES_DIR/$category_pkg"
        mkdir -p "$local_dir"
    else
        local_dir="$RECIPES_DIR/$pkg"
        mkdir -p "$local_dir"
    fi

    remote_base="${RECIPE_RAW_URL%/}/recipes/$(printf '%s' "$(printf '%s' "$local_dir" | sed "s|^${RECIPES_DIR}/||")")"

    required_files="version build"
    optional_files="depends package post_install post_remove checksums conflicts info sources"

    for file in $required_files $optional_files; do
        url="$remote_base/$file"
        dest="$local_dir/$file"
        if curl -fsSL "$url" -o "$dest" 2>/dev/null; then
            :
        else
            if printf '%s' "$required_files" | grep -q "$file"; then
                err "Failed to fetch mandatory file '$file' for package '$pkg' from $url"
                rm -rf "$local_dir"
                return 1
            fi
            rm -f "$dest"
        fi
    done

    chmod +x "$local_dir/build" 2>/dev/null || true
    chmod +x "$local_dir/package" 2>/dev/null || true
    chmod +x "$local_dir/post_install" 2>/dev/null || true
    chmod +x "$local_dir/post_remove" 2>/dev/null || true

    info "Recipe for '$pkg' refreshed successfully at $local_dir."
}

download_sources() {
    rpath="$1"; buildtmp="$2"
    sources_file="$rpath/sources"
    [ -f "$sources_file" ] || return 0

    info "Downloading source archives..."

    filtered_sources=$(grep -v '^[[:space:]]*#' "$sources_file" | grep -E -v '^[[:space:]]*$' || true)

    printf '%s\n' "$filtered_sources" | while IFS= read -r url; do
        url=$(printf '%s' "$url" | tr -d '[:space:]')
        [ -z "$url" ] && continue
        filename=$(basename "$url")
        dest_file="$buildtmp/$filename"

        info "  -> Downloading $filename"
        if ! curl -fsSL "$url" -o "$dest_file"; then
            err "Failed to download source file from $url"
        fi
    done
}

verify_checksums_and_extract() {
    pkg="$1"; rpath="$2"; buildtmp="$3"
    checksums_file="$rpath/checksums"
    [ -f "$checksums_file" ] || { info "No checksums provided for $pkg. Skipping integrity check."; return 0; }

    command -v sha256sum >/dev/null 2>&1 || err "sha256sum command not found. Cannot verify source integrity."

    info "Verifying source integrity using checksums..."

    while IFS= read -r line; do
        line=$(printf '%s' "$line" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
        [ -z "$line" ] && continue
        case "$line" in \#*) continue ;; esac

        expected_hash=$(printf '%s' "$line" | awk '{print $1}')
        filename=$(printf '%s' "$line" | awk '{print $2}')

        [ -n "$expected_hash" ] || err "Checksum file format error for $pkg. Line: '$line'"
        [ -n "$filename" ] || err "Checksum file format error for $pkg. Line: '$line'"

        file_path="$buildtmp/$filename"
        [ -f "$file_path" ] || err "Checksum error: Source file '$filename' not found in build directory. Cannot verify."

        actual_hash=$(sha256sum "$file_path" | awk '{print $1}')
        if [ "$actual_hash" != "$expected_hash" ]; then
            err "Checksum mismatch for $filename! Expected $expected_hash, got $actual_hash. Aborting."
        else
            info "  -> Checksum verified for $filename."
        fi
    done < "$checksums_file"

    info "Checksums verified. Extracting sources..."
    sources_file="$rpath/sources"
    while IFS= read -r url; do
        url=$(printf '%s' "$url" | grep -E -v '^[[:space:]]*#' | grep -E -v '^[[:space:]]*$' || true)
        [ -z "$url" ] && continue
        filename=$(basename "$url")
        dest_file="$buildtmp/$filename"
        info "  -> Extracting $filename"
        case "$filename" in
            *.tar.gz|*.tgz|*.tar.bz2|*.tbz|*.tar.xz|*.txz) tar -xf "$dest_file" -C "$buildtmp" || err "Extract failed for $filename" ;;
            *.zip)
                command -v unzip >/dev/null 2>&1 || err "unzip not found"
                unzip -q "$dest_file" -d "$buildtmp" || err "Unzip failed for $filename" ;;
            *)
                info "  -> Unknown archive type for $filename. Leaving as file."
                ;;
        esac
        rm -f "$dest_file"
    done < "$sources_file"
}

# --- BUILD / SYNC ---

sync_pkg_recursive() {
    pkg="$1"
    FORCE_CMD=${2:-0}  # Default 0 if not passed

    # If host provides it, skip unless forced
    if [ "$FORCE_CMD" -eq 0 ] && check_host_dependency "$pkg"; then
        info "Dependency '$pkg' satisfied by host. Skipping build/fetch."
        return 0
    fi

    fetch_remote_recipe "$pkg"
    recipe_dir=$(recipe_path "$pkg") || err "Recipe for '$pkg' not found."

    info "Checking dependencies for $pkg..."
    get_pkg_deps "$pkg" | while IFS= read -r dep_pkg; do
        dep_pkg=$(printf '%s' "$dep_pkg" | tr -d '[:space:]')
        [ -z "$dep_pkg" ] && continue
        sync_pkg_recursive "$dep_pkg" "$FORCE_CMD"
    done

    build_from_recipe "$pkg" "$FORCE_CMD"
}

# hoping that this fucking asura sync doesnt explode
sync_pkg_asura() {
    pkg="$1"
    FORCE_CMD=${2:-0}  # default 0 if not provided
    info "Syncing package '$pkg' from Asura (user repository)..."

    old_url="$RECIPE_RAW_URL"
    RECIPE_RAW_URL="$USER_RECIPE_RAW_URL"

    sync_pkg_recursive "$pkg" "$FORCE_CMD"

    RECIPE_RAW_URL="$old_url"
}

build_from_recipe() {
    pkg="$1"
    FORCE_CMD=${2:-$FORCE_BUILD}
    BUILD_BINPKG=${3:-0}

    rpath=$(recipe_path "$pkg") || err "recipe $pkg not found"
    recipe_ver="unknown"
    [ -f "$rpath/version" ] && recipe_ver=$(cat "$rpath/version")
    installed_ver=$(get_installed_ver "$pkg")
    
    # DRY-RUN MODE
    if [ "$DRY_RUN" -eq 1 ]; then
        info "[DRY-RUN] Would build package: $pkg"
        info "[DRY-RUN] Recipe version: $recipe_ver"
        info "[DRY-RUN] Installed version: $installed_ver"
        
        # Check dependencies
        info "[DRY-RUN] Dependencies:"
        deps=$(get_pkg_deps "$pkg")
        if [ -n "$deps" ]; then
            printf '%s\n' "$deps" | while IFS= read -r dep; do
                dep=$(printf '%s' "$dep" | tr -d '[:space:]')
                [ -z "$dep" ] && continue
                if is_pkg_installed "$dep"; then
                    info "[DRY-RUN]   ✓ $dep (installed)"
                else
                    info "[DRY-RUN]   ✗ $dep (would be installed)"
                fi
            done
        else
            info "[DRY-RUN]   (none)"
        fi
        
        # Run safety checks
        check_script_safety "$rpath/build" "$pkg"
        [ -f "$rpath/package" ] && check_script_safety "$rpath/package" "$pkg"
        
        info "[DRY-RUN] Build would complete successfully (no actual build performed)"
        return 0
    fi
    
    # Run safety checks on build scripts
    check_script_safety "$rpath/build" "$pkg"
    [ -f "$rpath/package" ] && check_script_safety "$rpath/package" "$pkg"
    [ -f "$rpath/post_install" ] && check_script_safety "$rpath/post_install" "$pkg"

    if [ "$installed_ver" != "none" ]; then
        if [ "$installed_ver" = "$recipe_ver" ] && [ "$FORCE_CMD" -eq 0 ]; then
            info "Package '$pkg' is already installed at version $installed_ver. Skipping."
            return 0
        elif [ "$FORCE_CMD" -eq 1 ]; then
            info "Force rebuilding $pkg."
        else
            info "Upgrading '$pkg' from $installed_ver to $recipe_ver..."
        fi
    else
        info "Installing '$pkg' version $recipe_ver..."
    fi
    check_file_conflicts "$pkg" "$PKGDIR" "$FORCE_CMD"
    info "Installing $pkg files to root filesystem ($INSTALL_ROOT)..."
    buildtmp="$TMPDIR/astral-build-$pkg-$$"
    mkdir -p "$buildtmp"
    if [ -d "$rpath" ]; then
        cp -a "$rpath"/* "$buildtmp"/ 2>/dev/null || true
    else
        err "Directory recipe structure not found for $pkg."
    fi
    cd "$buildtmp" || err "cd failed"

    trap "rm -rf '$buildtmp'" EXIT

    # download_sources "$rpath" "$buildtmp"
    verify_checksums_and_extract "$pkg" "$rpath" "$buildtmp"

    if [ -f "./build" ]; then
        chmod +x ./build || true
        PKGDIR="$buildtmp/pkg"
        mkdir -p "$PKGDIR"

        info "Starting isolated build for $pkg..."
        ( DESTDIR="$PKGDIR" ./build ) || err "build failed for $pkg"

        if [ -f "./package" ]; then
            info "Running package hook for $pkg..."
            ( DESTDIR="$PKGDIR" PKGDIR="$PKGDIR" ./package ) || err "package() failed for $pkg"
        fi

        create_meta "$pkg" "$recipe_ver" "x86_64" "$PKGDIR"

        new_files=$(
            ( cd "$PKGDIR" && find . -mindepth 1 -print ) \
            | sed 's/^\.\///' \
            | grep -v '^\.astral-meta$' \
            || true
        )

        info "Installing $pkg files to root filesystem ($INSTALL_ROOT)..."
        tar -C "$PKGDIR" -cf - . | tar -C "$INSTALL_ROOT" -xf - || err "failed to extract package files"

        db_path=$(printf '%s' "$rpath" | sed "s|^${RECIPES_DIR}/||")
        pkgdir="$DB_DIR/$db_path"
        mkdir -p "$pkgdir"
        printf '%s\n' "$recipe_ver" > "$pkgdir/version"
        printf '%s\n' "$new_files" > "$pkgdir/files"

        if [ -f "$buildtmp/depends" ]; then
            cp "$buildtmp/depends" "$pkgdir/depends"
        fi

        if [ -f "$buildtmp/post_install" ]; then
            info "Running post_install hook for $pkg..."
            ( DESTDIR="$INSTALL_ROOT" PKGDIR="$PKGDIR" "$buildtmp/post_install" ) || info "Warning: post_install failed for $pkg"
        fi

        info "Successfully installed $pkg ($recipe_ver)."
    else
        err "Recipe $pkg has no build script"
    fi

    trap - EXIT
    rm -rf "$buildtmp"
}

update_repo() {
    repo="${1:-}"

    case "$repo" in
        aoharu|"")
            info "Updating Axia Official Repository Index (AOHARU)..."
            INDEX_FILE="$INDEX_FILE_AOHARU"
            INDEX_URL="${REPO_URL}astral.index"
            ;;
        asura)
            info "Updating Axia User Repository For All Indeks (ASURA)..."
            INDEX_FILE="$INDEX_FILE_ASURA"
            INDEX_URL="${USER_REPO_URL}/astral.index"
            ;;
        *)
            err "Unknown repository '$repo' for update"
            ;;
    esac

    if curl -fsSL "$INDEX_URL" -o "$INDEX_FILE"; then
        info "Database updated successfully."
    else
        err "Failed to download index from $INDEX_URL"
        return 1
    fi
}


# rewritten... hopes that it doesnt fucking explode
search_pkg() {
    query="$1"
    info "Searching for package '$query'..."

    # --- Local recipes ---
    info "--- Local Recipes ($RECIPES_DIR) ---"
    found_local=0
    for r in $(find "$RECIPES_DIR" -type d -mindepth 1 -maxdepth 2 2>/dev/null); do
        pkg_name=$(basename "$r")
        if printf '%s\n' "$pkg_name" | grep -iq "$query"; then
            ver="unknown"
            [ -f "$r/version" ] && ver=$(cat "$r/version")
            printf "L: %-20s (v%s) [%s]\n" "$pkg_name" "$ver" "$(basename "$(dirname "$r")")"
            found_local=1
        fi
    done
    [ "$found_local" -eq 0 ] && info "No local recipes found."


    # Remote indexes
    info "--- Remote Indexes ---"
    for idx in "$INDEX_FILE_AOHARU" "$INDEX_FILE_ASURA"; do
        [ -f "$idx" ] || continue
        while IFS= read -r line; do
            pkg_name=$(printf '%s' "$line" | awk '{print $1}')
            pkg_ver=$(printf '%s' "$line" | awk '{print $2}')
            repo_label=$(basename "$idx" | sed 's/index_//')
            if printf '%s\n' "$pkg_name" | grep -iq "$query"; then
                printf "R(%s): %-20s (v%s)\n" "$repo_label" "$pkg_name" "$pkg_ver"
            fi
        done < "$idx"
    done
}


show_pkg_info() {
    requested_pkg="$1"
    pkg_path=$(resolve_installed_path "$requested_pkg") 2>/dev/null || pkg_path="$requested_pkg"

    rpath=$(recipe_path "$requested_pkg") 2>/dev/null || rpath=""
    recipe_exists=0
    [ -n "$rpath" ] && recipe_exists=1

    info "--- Package Information: $pkg_path ---"

    installed_ver=$(get_installed_ver "$requested_pkg")
    printf "Installed Version: %s\n" "$installed_ver"
    if [ "$installed_ver" != "none" ]; then
        pkgdir="$DB_DIR/$pkg_path"
        installed_date="N/A"
        [ -f "$pkgdir/files" ] && installed_date=$(stat -c "%y" "$pkgdir/files" 2>/dev/null || echo "N/A")
        printf "Installed Path:    %s\n" "$pkgdir"
        printf "Installation Date: %s\n" "$installed_date"
        printf "Installed Files:   %s files\n" "$(wc -l < "$pkgdir/files" 2>/dev/null || echo 0)"

        installed_deps_list="None"
        installed_deps_count=0
        installed_deps=$(get_pkg_deps "$pkg_path" || true)
        if [ -n "$installed_deps" ]; then
             installed_deps_list=$(printf '%s' "$installed_deps" | tr '\n' ' ')
             installed_deps_count=$(printf '%s\n' "$installed_deps" | wc -l)
        fi
        printf "Dependencies (%s): %s\n" "$installed_deps_count" "$installed_deps_list"
    fi

    if [ "$recipe_exists" -eq 1 ]; then
        recipe_ver=$(cat "$rpath/version" 2>/dev/null || echo "unknown")
        printf "\nRecipe Found:      Yes\n"
        printf "Recipe Version:    %s\n" "$recipe_ver"
        printf "Recipe Path:       %s\n" "$rpath"

        recipe_deps_list="None"
        recipe_deps_count=0
        recipe_deps=$(get_pkg_deps "$requested_pkg" || true)
        if [ -n "$recipe_deps" ]; then
            recipe_deps_list=$(printf '%s' "$recipe_deps" | tr '\n' ' ')
            recipe_deps_count=$(printf '%s\n' "$recipe_deps" | wc -l)
        fi
        printf "Recipe Deps (%s):   %s\n" "$recipe_deps_count" "$recipe_deps_list"

        conflicts_list="None"
        conflicts_count=0
        if [ -f "$rpath/conflicts" ]; then
            filtered_conflicts=$(grep -v '^[[:space:]]*#' "$rpath/conflicts" | grep -E -v '^[[:space:]]*$' || true)
            conflicts_list=$(printf '%s' "$filtered_conflicts" | tr '\n' ' ')
            conflicts_count=$(printf '%s\n' "$filtered_conflicts" | wc -l)
        fi
        printf "Conflicts (%s):     %s\n" "$conflicts_count" "$conflicts_list"
        printf "Build Script:      %s\n" "$( [ -f "$rpath/build" ] && echo "Yes" || echo "No" )"
        printf "Package Script:    %s\n" "$( [ -f "$rpath/package" ] && echo "Yes" || echo "No" )"
        printf "Checksums:         %s\n" "$( [ -f "$rpath/checksums" ] && echo "Yes" || echo "No" )"
    else
        printf "\nRecipe Found:      No (Run 'astral -s %s' to fetch)\n" "$requested_pkg"
    fi
}

upgrade_all() {
    FORCE_CMD=${1:-0}  # 0 if not passed
    info "Starting full system upgrade (syncing all installed packages)..."

    count=0
    success_count=0

    find "$DB_DIR" -type f -name "version" -maxdepth 3 2>/dev/null |
    sed "s|^${DB_DIR}/||" | sed 's|/version$||' |
    while IFS= read -r pkg_path; do
        pkg=$(basename "$pkg_path")
        info "\n>>> Checking $pkg_path <<<"
        if sync_pkg_recursive "$pkg" "$FORCE_CMD"; then
            success_count=$((success_count + 1))
        else
            info "Warning: Failed to sync $pkg_path. Check logs."
        fi
        count=$((count + 1))
    done

    info "\nUpgrade process finished. Checked $count installed packages. $success_count updated/verified."
}

self_update() {
    TMPDIR="${TMPDIR:-/tmp}"
    tmp_file=$(mktemp "$TMPDIR/astral-new.XXXXXX") || err "mktemp failed"
    trap 'rm -f "$tmp_file"' EXIT

    branch="${1:-main}"
    case "$branch" in
        main) 
            update_url="$SELF_UPDATE_URL_MAIN"
            info "Starting astral self-update from 'main' branch ($update_url)..."
        ;;
        cutting-edge) 
            update_url="$SELF_UPDATE_URL_CUTTING_EDGE" 
            info "Starting astral self-update from 'cutting-edge' branch ($update_url)..."
        ;;
        bleeding-edge) 
            update_url="$SELF_UPDATE_URL_BLEEDING_EDGE" 
            info "Starting astral self-update from 'bleeding-edge' branch ($update_url)..."
        ;;
        *)    
            err "Unknown update branch '$branch'"; 
            return 1 
        ;;
    esac

    command -v curl >/dev/null 2>&1 || { err "curl not found"; return 1; }

    if ! curl -fsSL "$update_url" -o "$tmp_file"; then
        err "Failed to download new astral script from $update_url"; return 1
    fi

    if ! head -n 1 "$tmp_file" | grep -qE '^#!'; then
        err "Downloaded file invalid (missing shebang)"; return 1
    fi

    chmod +x "$tmp_file"
    if mv -f "$tmp_file" "$SELF_UPDATE_PATH"; then
        info "Self-update successful!"
        trap - EXIT
    else
        err "Failed to replace $SELF_UPDATE_PATH"
        return 1
    fi
}

# --- SAFE REMOVAL HELPERS ---

remove_pkg_only() {
    # Accepts canonical pkg path (relative to DB_DIR)
    pkg_path="$1"
    pkgdir="$DB_DIR/$pkg_path"
    [ -d "$pkgdir" ] || return 0

    info "Removing package database entry: $pkg_path"

    # Pre-remove hook (try recipe's post_remove if present)
    rpath=$(recipe_path "$(basename "$pkg_path")") 2>/dev/null || rpath=""
    if [ -n "$rpath" ] && [ -f "$rpath/post_remove" ]; then
        info "Running post_remove hook for $(basename "$pkg_path")..."
        ( "$rpath/post_remove" ) || info "Warning: post_remove hook failed for $pkg_path"
    fi

    if [ -f "$pkgdir/files" ]; then
        while IFS= read -r f; do
            [ -z "$f" ] && continue
            fullpath="$INSTALL_ROOT/$f"
            if [ -f "$fullpath" ] || [ -L "$fullpath" ]; then
                rm -f "$fullpath" 2>/dev/null || true
            fi
            # collect directories for later cleanup: append only directories (will be rmdir attempted)
            case "$f" in
                */)
                    echo "$f" >> "$TMPDIR/astral-dirs-$$" ;;
                *)
                    dirp=$(dirname "$f")
                    [ "$dirp" != "." ] && echo "$dirp" >> "$TMPDIR/astral-dirs-$$" || true
                    ;;
            esac
        done < "$pkgdir/files"
    fi

    # Clean up directories (deepest first)
    if [ -f "$TMPDIR/astral-dirs-$$" ]; then
        sort -r "$TMPDIR/astral-dirs-$$" | while IFS= read -r d; do
            [ -z "$d" ] && continue
            rmdir "$INSTALL_ROOT/$d" 2>/dev/null || true
        done
        rm -f "$TMPDIR/astral-dirs-$$"
    fi

    # Remove DB entry
    rm -rf "$pkgdir"
    info "Removed $pkg_path from database."
}

removedep_pkg() {
    pkg="$1"
    initial_pkg_path=$(resolve_installed_path "$pkg") || err "package $pkg not installed"

    # Capture the initial package's declared dependencies (from DB or recipe)
    declared_deps=$(get_pkg_deps "$initial_pkg_path" || true)

    # Remove only the initial package
    remove_pkg_only "$initial_pkg_path"

    # For safety: only consider deps that were declared by the removed package.
    # Remove only those deps that are now orphans (no other package requires them).
    if [ -n "$declared_deps" ]; then
        printf '%s\n' "$declared_deps" | while IFS= read -r dep; do
            dep=$(printf '%s' "$dep" | tr -d '[:space:]')
            [ -z "$dep" ] && continue
            # If host provides it, skip removal
            if check_host_dependency "$dep"; then
                info "Dependency '$dep' provided by host; not removing."
                continue
            fi
            dep_path=$(resolve_installed_path "$dep") 2>/dev/null || true
            [ -z "$dep_path" ] && continue
            if ! is_pkg_required "$dep_path"; then
                info "Removing orphan dependency: $dep_path"
                remove_pkg_only "$dep_path"
                # after removing this dep, we should also consider its declared deps recursively (safe recursion)
                # collect its declared deps and process them similarly
                subdeps=$(get_pkg_deps "$dep_path" || true)
                if [ -n "$subdeps" ]; then
                    printf '%s\n' "$subdeps" | while IFS= read -r sdep; do
                        sdep=$(printf '%s' "$sdep" | tr -d '[:space:]')
                        [ -z "$sdep" ] && continue
                        sdep_path=$(resolve_installed_path "$sdep") 2>/dev/null || true
                        if [ -n "$sdep_path" ] && ! is_pkg_required "$sdep_path"; then
                            info "Removing transitive orphan dependency: $sdep_path"
                            remove_pkg_only "$sdep_path"
                        fi
                    done
                fi
            else
                info "Keeping dependency $dep_path (still required)."
            fi
        done
    fi

    info "Orphan dependency cleanup complete."
}

remove_pkg() {
    requested_pkg="$1"
    pkg_path=$(resolve_installed_path "$requested_pkg") || err "package $requested_pkg not installed"
    remove_pkg_only "$pkg_path"
}

clean_cache() {
    info "Starting recipe cache cleanup in $RECIPES_DIR..."
    find "$RECIPES_DIR" -type d -mindepth 2 -maxdepth 2 2>/dev/null | while IFS= read -r recipe_dir; do
        pkg_name=$(basename "$recipe_dir")
        if is_pkg_installed "$pkg_name"; then
            info "Recipe for '$pkg_name' is installed. Skipping."
        else
            info "Removing cached recipe for '$pkg_name'..."
            rm -rf "$recipe_dir"
        fi
    done
    info "Cache cleanup complete."
}

list_installed() {
    if [ ! -d "$DB_DIR" ] || [ -z "$(ls -A "$DB_DIR" 2>/dev/null)" ]; then
        info "No packages currently installed."
        return 0
    fi
    info "--- Installed Packages ---"
    last_category=""
    find "$DB_DIR" -type f -name "version" -maxdepth 3 2>/dev/null |
    sed "s|^${DB_DIR}/||" | sed 's|/version$||' | sort |
    while IFS= read -r pkg_path; do
        pkg_name=$(basename "$pkg_path")
        category=$(dirname "$pkg_path")
        pkg_ver=""
        if [ "$category" = "." ] || [ -z "$category" ] || [ "$category" = "/" ]; then
            category="Uncategorized"
        fi
        if [ "$category" != "$last_category" ]; then
            printf '%s\n' "$category"
            last_category="$category"
        fi
        if [ -f "$DB_DIR/$pkg_path/version" ]; then
             pkg_ver=$(cat "$DB_DIR/$pkg_path/version")
        fi
        printf "|- %-15s (v%s)\n" "$pkg_name" "$pkg_ver"
    done
    printf '\n'
}
# Add after list_installed() function

check_deps_tree() {
    pkg="$1"
    prefix="${2:-}"
    visited="${3:-}"
    
    is_visited=0
    for v in $visited; do
        [ "$v" = "$pkg" ] && is_visited=1 && break
    done
    
    if [ $is_visited -eq 1 ]; then
        printf '%s%s [CIRCULAR]\n' "$prefix" "$pkg"
        return 0
    fi
    
    visited="$visited $pkg"
    
    if is_pkg_installed "$pkg"; then
        installed_ver=$(get_installed_ver "$pkg")
        printf '%s%s [installed: v%s]\n' "$prefix" "$pkg" "$installed_ver"
    else
        if check_host_dependency "$pkg"; then
            printf '%s%s [host-provided]\n' "$prefix" "$pkg"
            return 0
        fi
        
        if recipe_path "$pkg" >/dev/null 2>&1; then
            rpath=$(recipe_path "$pkg")
            recipe_ver=$(cat "$rpath/version" 2>/dev/null || echo "unknown")
            printf '%s%s [available: v%s]\n' "$prefix" "$pkg" "$recipe_ver"
        else
            printf '%s%s [NOT FOUND!]\n' "$prefix" "$pkg"
            return 0
        fi
    fi
    
    deps=$(get_pkg_deps "$pkg" || true)
    [ -z "$deps" ] && return 0
    
    printf '%s\n' "$deps" | while IFS= read -r dep; do
        dep=$(printf '%s' "$dep" | tr -d '[:space:]')
        [ -z "$dep" ] && continue
        check_deps_tree "$dep" "$prefix  ├─ " "$visited"
    done
}

show_deps() {
    pkg="$1"
    info "=== Dependency Tree for '$pkg' ==="
    check_deps_tree "$pkg" "" ""
    info ""
}

check_system_deps() {
    info "=== Checking System Dependencies ==="
    broken_count=0
    
    pkgs_tmp=$(mktemp "$TMPDIR/astral-depcheck.XXXXXX") || err "mktemp failed"
    find "$DB_DIR" -type f -name "version" -maxdepth 3 2>/dev/null | \
        sed "s|^${DB_DIR}/||" | sed 's|/version$||' > "$pkgs_tmp"
    
    while IFS= read -r pkg_path; do
        pkg_name=$(basename "$pkg_path")
        deps=$(get_pkg_deps "$pkg_path" || true)
        [ -z "$deps" ] && continue
        
        has_broken=0
        printf '%s\n' "$deps" | while IFS= read -r dep; do
            dep=$(printf '%s' "$dep" | tr -d '[:space:]')
            [ -z "$dep" ] && continue
            
            if ! is_pkg_installed "$dep" && ! check_host_dependency "$dep"; then
                if [ $has_broken -eq 0 ]; then
                    info "✗ $pkg_name has broken dependencies:"
                    has_broken=1
                fi
                info "  - Missing: $dep"
            fi
        done
        
        [ $has_broken -eq 1 ] && broken_count=$((broken_count + 1))
    done < "$pkgs_tmp"
    rm -f "$pkgs_tmp"
    
    if [ $broken_count -eq 0 ]; then
        info "✓ No broken dependencies found!"
    else
        info "✗ Found packages with broken dependencies."
    fi
}

# --- ENTRY / CLI PARSING ---

# Require root for all operations (astral must be invoked by root, sudo, or doas)
if [ "$(id -u)" -ne 0 ]; then
    err "Astral must be run as root (via sudo or doas)."
fi

# --- Global Option Parsing ---
while [ $# -gt 0 ]; do
    case "$1" in
        --dir)
            [ $# -lt 2 ] && err "Missing argument for $1"
            INSTALL_ROOT="$2"
            shift 2
            ;;
        --dir=*)
            INSTALL_ROOT="${1#*=}"
            shift
            ;;
        -f|--force)
            FORCE_BUILD=1
            shift
            ;;
        -n|--dry-run)
            DRY_RUN=1
            shift
            ;;
        -V|--version)
            astral_version
            ;;
        --)
            shift
            break
            ;;
        -*) # start of command
            break
            ;;
        *)
            break
            ;;
    esac
done

if [ $# -lt 1 ]; then usage; exit 1; fi

if [ "$INSTALL_ROOT" != "/" ]; then
    INSTALL_ROOT="${INSTALL_ROOT%/}"
    info "Global: Installation root set to: $INSTALL_ROOT"
fi
ensure_default_config
load_config

case "$1" in
-S|--Sync)
    [ $# -gt 1 ] || err "package name required"
    VISITED_PACKAGES=""
    sync_pkg_recursive "$2" "$FORCE_BUILD"
    FORCE_BUILD=0
    ;;

-C|--Compile)
    [ $# -gt 1 ] || err "package name required"
    VISITED_PACKAGES=""
    build_from_recipe "$2" "$FORCE_BUILD"
    FORCE_BUILD=0
    ;;

-SA|--Sync-Asura)
    [ $# -gt 1 ] || err "package name required"
    VISTED_PACKAGES=""
    sync_pkg_asura "$2"
    FORCE_BUILD=0
    ;;

--Upgrade-All|-UA)
    upgrade_all
    ;;

  -u|--Update)
    repo="$2"
    shift 2
    update_repo "$repo"
    ;;

  -s|--Search)
    [ $# -gt 1 ] || err "package name required"
    search_pkg "$2"
    ;;

  -R|--Remove)
    [ $# -gt 1 ] || err "package name required"
    remove_pkg "$2"
    ;;

  -r|--RemoveDep)
    [ $# -gt 1 ] || err "package name required"
    removedep_pkg "$2"
    ;;

  -Cc|--Clean-Cache)
    clean_cache
    ;;

  -U|--self-update)
    self_update "${2:-main}"
    ;;

  --info|-I)
    [ $# -gt 1 ] || err "package name required"
    show_pkg_info "$2"
    ;;

  --inspect|-Ins)
    [ $# -gt 1 ] || err "package name required"
    r=$(recipe_path "$2") || err "recipe not found for $2"
    info "--- Files in Recipe Directory: $r ---"
    if [ -d "$r" ]; then
      ls -la "$r"
      [ -f "$r/info" ] && { info "\n--- PACKAGE INFO ($2) ---\n"; cat "$r/info"; }
      [ -f "$r/build" ] && { info "\n--- BUILD SCRIPT HEAD ($2) ---\n"; sed -n '1,20p' "$r/build"; }
    else
      info "--- Single Recipe File Content ($2) ---\n"
      sed -n '1,20p' "$r"
    fi
    ;;

  --list-installed|-ll)
    list_installed
    ;;
-D|--Deps)
    [ $# -gt 1 ] || err "package name required"
    show_deps "$2"
    ;;

-Dc|--DepCheck)
    check_system_deps
    ;;

--config)
    info "=== Astral Configuration ==="
    printf "Config File:      %s\n" "$CONFIG_FILE"
    printf "USE_FLAGS:        %s\n" "$USE_FLAGS"
    printf "CFLAGS:           %s\n" "$CFLAGS"
    printf "MAKEFLAGS:        %s\n" "$MAKEFLAGS"
    printf "CCACHE_ENABLED:   %s\n" "$CCACHE_ENABLED"
    printf "BINPKG_ENABLED:   %s\n" "$BINPKG_ENABLED"
    printf "FEATURES:         %s\n" "$FEATURES"
    ;;

  -V|--Version)
    astral_version
    ;;

  -https://www.youtube.com/watch?v=2EDcoWKH25o)
    echo "Flash Me Back - Camemellia. Peak btw"
    ;;

  *|-*|--*)
    echo "Error: Unknown command or option '$1'" >&2
    usage
    exit 1
    ;;

esac

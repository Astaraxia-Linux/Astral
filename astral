#!/bin/sh
# Astral v0.1 - minimal POSIX package manager for Astaraxia
# Simple hybrid: build from recipes or install cached binaries.
# Minimal dependencies: sh, tar, wget, xz (or gzip), python3 (optional for JSON) idk :p

set -eu

RECIPES_DIR=${RECIPES_DIR:-/usr/src/astral/recipes}
CACHE_SRC=${CACHE_SRC:-/var/cache/astral/src}
CACHE_BIN=${CACHE_BIN:-/var/cache/astral/bin}
DB_DIR=${DB_DIR:-/var/lib/astral/db}
REPO_URL=${REPO_URL:-https://izumi-sonoka.github.io/Astral-Repo/}
INDEX_FILE="$DB_DIR/index" # /var/lib/astral/db/index
LOG_DIR=${LOG_DIR:-/var/log/astral}
PKG_EXT=${PKG_EXT:-.asb}   # package extension (tar.xz)
TMPDIR=${TMPDIR:-/tmp}

mkdir -p "$RECIPES_DIR" "$CACHE_SRC" "$CACHE_BIN" "$DB_DIR" "$LOG_DIR" "$TMPDIR"

err() { printf 'ERROR: %s\n' "$*" >&2; exit 1; }
info() { printf '%s\n' "$*"; }

usage() {
  cat <<USAGE
Usage: astral <command> [pkg...]
Commands:
  -s, --sync <pkg>        Install package... idk
  -bin, --binary <pkg>    Force binary install
  -comp, --compile <pkg>  Build from recipe and install (produce binary)
  -u, --update            Updates package
  --search                Searches for package
  -R, --Remove <pkg>      Remove package (leave deps)
  -r, --RemoveDep <pkg>   Remove package and attempt to remove orphan deps
  -y, --All               Try to upgrade all installed packages (binary mode)
  --inspect <pkg>         Show recipe content
  --list-installed        List installed packages
USAGE
}

is_pkg_installed() {
  pkg="$1"
  [ -d "$DB_DIR/$pkg" ]
}

sync_pkg_recursive() {
    local pkg="$1"
    
    if is_pkg_installed "$pkg"; then
        info "Package '$pkg' is already installed. Skipping."
        return 0
    fi

    local recipe_dir="$(recipe_path "$pkg")"
    [ -z "$recipe_dir" ] && err "recipe $pkg not found for installation"

    local depsf="$recipe_dir/depends"
    if [ -f "$depsf" ]; then
        info "Checking dependencies for $pkg..."
        while IFS= read -r dep_pkg; do
            # Robust filtering
            dep_pkg=$(echo "$dep_pkg" | tr -d '[:space:]')
            if [ -z "$dep_pkg" ] || [ "${dep_pkg:0:1}" = "#" ]; then
                continue
            fi
            sync_pkg_recursive "$dep_pkg"
        done < "$depsf"
    fi

    info "Installing $pkg by building from source."
    build_from_recipe "$pkg"
}

update_repo() {
    info "Updating package database..."
    
    # Define the URL for the index file
    INDEX_URL="${REPO_URL}astral.index" # Note: Assuming astral.index is in the root of the repo
    
    # Use curl to download the index file
    # -f: Fail silently on HTTP errors, -sS: Silent but show errors, -L: Follow redirects
    if curl -fsSL "$INDEX_URL" -o "$INDEX_FILE"; then
        info "Database updated successfully: $(cat "$INDEX_FILE" | wc -l) packages found."
    else
        err "Failed to download index file from $INDEX_URL. Check REPO_URL or network."
        return 1
    fi
}

# helper: find recipe
recipe_path() {
  pkg="$1"
  [ -f "$RECIPES_DIR/$pkg/build" ] && echo "$RECIPES_DIR/$pkg" && return 0
  [ -f "$RECIPES_DIR/$pkg.astral" ] && echo "$RECIPES_DIR/$pkg.astral" && return 0
  return 1
}

# read metadata from recipe dir or file
read_recipe_meta() {
  r="$1"
  # If it's a dir with files, read version and sources if present
  if [ -d "$r" ]; then
    [ -f "$r/version" ] && ver=$(cat "$r/version") || ver=local
    [ -f "$r/sources" ] && srcf="$r/sources" || srcf=
    [ -f "$r/depends" ] && depsf="$r/depends" || depsf=
    printf 'pkgname=%s\npkgver=%s\nsources=%s\ndepends=%s\n' \
      "$(basename "$r")" "$ver" "$srcf" "$depsf"
  else
    # single-file recipe: print file for inspection
    printf 'file=%s\n' "$r"
  fi
}

# create package metadata file
create_meta() {
  pkg="$1"; ver="$2"; arch="$3"; dest="$4"
  cat > "$dest/.astral-meta" <<M
name=$pkg
version=$ver
arch=$arch
M
}

# build from recipe directory
build_from_recipe() {
    local pkg="$1"
    local rpath
    rpath=$(recipe_path "$pkg") || err "recipe $pkg not found"
    # build environment
    local buildtmp="$TMPDIR/astral-build-$pkg-$$"
    mkdir -p "$buildtmp"

    # if recipe is a directory, copy files ther
    if [ -d "$rpath" ]; then
        cp -a "$rpath"/* "$buildtmp"/
    else
        # single-file recipe case - copyy
        cp -a "$rpath" "$buildtmp/recipe.astral"
    fi
    cd "$buildtmp"

    # load recipe script if present (build/package functions expected)
    if [ -f "./build" ]; then
        chmod +x ./build || true
        # create safe packaging dir
        local PKGDIR="$buildtmp/pkg"
        mkdir -p "$PKGDIR"
        
        # run build in subshell
        ( cd "$buildtmp" && ./build ) || err "build failed for $pkg"
        
        # run package (should install into $PKGDIR)
        if [ -f "./package" ]; then
            ( cd "$buildtmp" && PKGDIR="$PKGDIR" ./package ) || err "package() failed for $pkg"
        else
            err "no package() script found for $pkg; recipe must provide package script"
        fi
        
        # create metadata
        local ver="unknown"
        [ -f "./version" ] && ver=$(cat ./version)
        create_meta "$pkg" "$ver" "x86_64" "$PKGDIR"
        
        info "Installing $pkg to root filesystem..."
        
        # 1. Install files from PKGDIR to /
        tar -C "$PKGDIR" -cf - . | tar -C / -xf - || err "failed to extract package files"
        
        # 2. Record installed files in the database
        local files=$(tar -C "$PKGDIR" -tf . | grep -v '^\.$' | grep -v '^\.\/$' | grep -v '^\.astral-meta$' || true)
        local pkgdir="$DB_DIR/$pkg"
        mkdir -p "$pkgdir"
        printf '%s\n' "$ver" > "$pkgdir/version"
        printf '%s\n' "$files" > "$pkgdir/files"
        
        # 3. Record Dependencies
        if [ -f "$buildtmp/depends" ]; then
            info "Recording build dependencies for $pkg."
            cp "$buildtmp/depends" "$pkgdir/depends"
        fi
        
        info "Installed $pkg ($ver) from source."
        
        # cleanup
        rm -rf "$buildtmp"
    else
        err "Recipe $pkg has no build script"
    fi
}

# Removing package
remove_pkg() {
    pkg="$1"
    pkgdir="$DB_DIR/$pkg"
    [ -d "$pkgdir" ] || err "package $pkg not installed"
    info "Removing $pkg"

    # List of directories to check for cleanup later (reverse order for safety)
    local dirs_to_check=""

    while IFS= read -r f; do
        [ -z "$f" ] && continue

        # --- A. Check for Protected System Paths (Keep this safety) ---
        case "$f" in
            bin|lib|sbin|usr|etc|\
            bin/*|lib/*|sbin/*|usr/*|etc/*|\
            /bin|/lib|/sbin|/usr|/etc|\
            /bin/*|/lib/*|/sbin/*|/usr/*|/etc/*)
                info "Skipping protected system path: $f"
                continue
                ;;
        esac

        # --- B. Record Directories ---
        if [ -d "/$f" ]; then
            dirs_to_check="$f $dirs_to_check" # Prepend to get reverse order
            continue # Skip directory entry removal now
        fi

        # --- C. Remove File ---
        if [ -e "/$f" ]; then
            rm -f "/$f" || info "warning: failed to remove /$f"
        fi

    done < "$pkgdir/files"

    # --- D. Empty Directory Cleanup (The Critical Safety Step) ---
    info "Checking for empty directories..."
    for d in $dirs_to_check; do
        # Use rmdir to only remove if empty
        rmdir "/$d" 2>/dev/null || info "Directory /$d not empty or protected."
    done

    rm -rf "$pkgdir"
    info "Removed $pkg"
}

# Helper function to get a package's dependencies (from its DB entry, if it has ever existed lol)
get_pkg_deps() {
local pkg="$1"
    local depfile="$DB_DIR/$pkg/depends"
    
    # Check if the depends file exists
    [ -f "$depfile" ] || return 0
    cat "$depfile" | grep -v '^\s*#' | grep -v '^\s*$' | tr -d '[:space:]'
}

# Check if a package is required by any other currently installed package
is_pkg_required() {
    local target_pkg="$1"
    
    for other_pkg_dir in "$DB_DIR"/*; do
        
        # 1. Skip if the entry is not a directory.
        [ -d "$other_pkg_dir" ] || continue 
        
        # 2. Assign the package name and ensure it's not empty (prevents unbound error)
        local other_pkg=$(basename "$other_pkg_dir") 
        [ -z "$other_pkg" ] && continue
        
        # 3. Skip if it's the package we are currently trying to remove.
        [ "$other_pkg" = "$target_pkg" ] && continue
          if get_pkg_deps "$other_pkg" | grep -q "^${target_pkg}$"; then
              return 0 # Required
          fi
      done
      return 1 # Not required by anyone else (is an orphan)
  }

# Remove package and attempt to remove orphan dependencies
removedep_pkg() {
    pkg="$1"
    
    # 1. Remove the target package first
    remove_pkg "$pkg"

    # 2. Iterate and check for new orphans until no more are found
    info "Scanning for orphaned dependencies..."
    removed_a_dep=0
    
    while true; do
        found_orphan=0
        
        for dep_dir in "$DB_DIR"/*; do
            [ -d "$dep_dir" ] || continue
            dep_name=$(basename "$dep_dir")

            # Check if this package is required by anyone else other than the pkg itself
            if ! is_pkg_required "$dep_name"; then
                info "Removing orphan dependency: $dep_name"
                # Call simple remove_pkg to avoid infinite recursion
                remove_pkg "$dep_name"
                found_orphan=1
                removed_a_dep=1
                break # Restart the loop after removing a package, as the dependency landscape has changed
            fi
        done

        # If we iterated through all packages and didn't find any orphans, we're done.
        [ "$found_orphan" -eq 0 ] && break
    done

    if [ "$removed_a_dep" -eq 0 ]; then
        info "No orphaned dependencies found."
    fi
}


list_installed() {
  for d in "$DB_DIR"/*; do
    [ -d "$d" ] || continue
    printf '%s %s\n' "$(basename "$d")" "$(cat "$d/version" 2>/dev/null || echo unknown)"
  done
}

# CLI dispatch
if [ $# -lt 1 ]; then usage; exit 1; fi

case "$1" in
-s|--sync)
    [ $# -gt 1 ] || err "pkg required"
    sync_pkg_recursive "$2"
    ;;
  #-bin|--binary) <--- REMOVED

  -comp|--compile)
    [ $# -gt 1 ] || err "pkg required"
    build_from_recipe "$2"
    ;;
  -u|--update)
    update_repo
    ;;
-R|--Remove)
    [ $# -gt 1 ] || err "pkg required"
    remove_pkg "$2"
    ;;
  -r|--RemoveDep)
    [ $# -gt 1 ] || err "pkg required"
    removedep_pkg "$2"
    ;;
  -y|--All)
    info "Upgrade all functionality removed (no binary support). Listing installed packages."
    list_installed
    ;;
  --inspect)
    [ $# -gt 1 ] || err "pkg required"
    r=$(recipe_path "$2") || err "recipe not found"
    if [ -d "$r" ]; then
      ls -la "$r"
      [ -f "$r/build" ] && sed -n '1,200p' "$r/build"
    else
      sed -n '1,200p' "$r"
    fi
    ;;
  --list-installed)
    list_installed
    ;;
  *)
    usage
    ;;
esac

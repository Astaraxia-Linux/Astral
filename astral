#!/bin/sh
# Astral v0.2 - minimal POSIX package manager for Astaraxia
# Features: Source-only, Auto-recipe fetch, Version locking, Build isolation.

set -eu

# Directory Layout
RECIPES_DIR=${RECIPES_DIR:-/usr/src/astral/recipes}
CACHE_SRC=${CACHE_SRC:-/var/cache/astral/src}
CACHE_BIN=${CACHE_BIN:-/var/cache/astral/bin}
DB_DIR=${DB_DIR:-/var/lib/astral/db}
REPO_URL=${REPO_URL:-https://izumi-sonoka.github.io/Astral-Repo/}                                  # URL for index/metadata (GitHub Pages)
# Note: Keeping this definition without a trailing slash for cleanliness.
RECIPE_RAW_URL=${RECIPE_RAW_URL:-https://raw.githubusercontent.com/Izumi-Sonoka/Astral-Repo/main} # Base URL for raw recipe files
INDEX_FILE="$DB_DIR/index"
LOG_DIR=${LOG_DIR:-/var/log/astral}
SELF_UPDATE_URL=${SELF_UPDATE_URL:-https://raw.githubusercontent.com/Astaraxia-Linux/Astral/refs/heads/main/astral}
SELF_UPDATE_PATH=/usr/bin/astral
TMPDIR=${TMPDIR:-/tmp}

mkdir -p "$RECIPES_DIR" "$CACHE_SRC" "$CACHE_BIN" "$DB_DIR" "$LOG_DIR" "$TMPDIR"

err() { printf 'ERROR: %s\n' "$*" >&2; exit 1; }
info() { printf '%s\n' "$*"; }

usage() {
  cat <<USAGE
Usage: astral <command> [pkg...]
Commands:
  -s, --sync <pkg>        Download recipe (if missing), check deps, and install/upgrade.
  -comp, --compile <pkg>  Build from recipe and install (force build).
  -u, --update            Updates the remote package index (for search).
  --search <pkg>          Searches for package in local recipes and remote index.
  -R, --Remove <pkg>      Remove package (leave deps).
  -r, --RemoveDep <pkg>   Remove package and attempt to remove orphan deps.
  -U, --self-update       Update the astral script itself from GitHub.
  --inspect <pkg>         Show recipe content.
  --list-installed        List installed packages.
USAGE
}

# --- CORE UTILITY FUNCTIONS ---

is_pkg_installed() {
  pkg="$1"
  [ -d "$DB_DIR/$pkg" ]
}

# helper: find recipe path
recipe_path() {
  pkg="$1"
  [ -f "$RECIPES_DIR/$pkg/build" ] && echo "$RECIPES_DIR/$pkg" && return 0
  [ -f "$RECIPES_DIR/$pkg.astral" ] && echo "$RECIPES_DIR/$pkg.astral" && return 0
  return 1
}

# Get installed version (returns "none" if not installed)
get_installed_ver() {
    local pkg="$1"
    if [ -f "$DB_DIR/$pkg/version" ]; then
        cat "$DB_DIR/$pkg/version"
    else
        echo "none"
    fi
}

create_meta() {
  pkg="$1"; ver="$2"; arch="$3"; dest="$4"
  cat > "$dest/.astral-meta" <<M
name=$pkg
version=$ver
arch=$arch
M
}

get_pkg_deps() {
    local pkg="$1"
    local depfile="$DB_DIR/$pkg/depends"
    [ -f "$depfile" ] || return 0
    cat "$depfile" | grep -v '^\s*#' | grep -v '^\s*$' | tr -d '[:space:]'
}

is_pkg_required() {
    local target_pkg="$1"
    for other_pkg_dir in "$DB_DIR"/*; do
        [ -d "$other_pkg_dir" ] || continue 
        local other_pkg=$(basename "$other_pkg_dir") 
        [ -z "$other_pkg" ] && continue
        [ "$other_pkg" = "$target_pkg" ] && continue
        if get_pkg_deps "$other_pkg" | grep -q "^${target_pkg}$"; then
            return 0 # Required
        fi
    done
    return 1 # Not required
}

# --- NETWORKING FUNCTIONS ---

# Fetch recipe files from remote if they don't exist locally
fetch_remote_recipe() {
    local pkg="$1"
    local local_dir="$RECIPES_DIR/$pkg"
    
    # If recipe exists locally, we skip downloading (as per your request)
    if [ -d "$local_dir" ] && [ -f "$local_dir/build" ]; then
        return 0
    fi

    info "Recipe for '$pkg' not found locally. Attempting to fetch from remote..."
    
    # Create the directory
    mkdir -p "$local_dir"

    # List of files to fetch. 'build' and 'package' and 'version' are mandatory.
    local required_files="version build package sources"
    local optional_files="depends"
    
    # FIX: Use parameter expansion to safely remove any trailing slash from the base URL.
    local clean_raw_url="${RECIPE_RAW_URL%/}"
    local remote_base="${clean_raw_url}/recipes/$pkg"

    for file in $required_files $optional_files; do
        local url="$remote_base/$file"
        local dest="$local_dir/$file"
        
        # Download silently (-s), fail on 404 (-f)
        if curl -fsSL "$url" -o "$dest"; then
            :
        else
            if echo "$required_files" | grep -q "$file"; then
                err "Failed to fetch mandatory file '$file' for package '$pkg' from $url"
                rm -rf "$local_dir"
                return 1
            fi
            # If optional file fails (like depends), just ignore
            rm -f "$dest"
        fi
    done
    
    # Make scripts executable
    chmod +x "$local_dir/build" 2>/dev/null || true # package might not be there if single file recipe
    chmod +x "$local_dir/package" 2>/dev/null || true
    info "Recipe for '$pkg' downloaded successfully."
}

# --- COMMAND IMPLEMENTATION FUNCTIONS ---

sync_pkg_recursive() {
    local pkg="$1"
    
    # 1. Ensure we have the recipe (Download if missing)
    fetch_remote_recipe "$pkg"

    local recipe_dir="$(recipe_path "$pkg")"
    [ -z "$recipe_dir" ] && err "Recipe for '$pkg' could not be found or downloaded."

    # 2. Handle Dependencies (Recursive)
    local depsf="$recipe_dir/depends"
    if [ -f "$depsf" ]; then
        info "Checking dependencies for $pkg..."
        while IFS= read -r dep_pkg; do
            dep_pkg=$(echo "$dep_pkg" | tr -d '[:space:]')
            if [ -z "$dep_pkg" ] || [ "${dep_pkg:0:1}" = "#" ]; then
                continue
            fi
            sync_pkg_recursive "$dep_pkg"
        done < "$depsf"
    fi

    # 3. Build/Install (Version check happens inside build_from_recipe)
    build_from_recipe "$pkg"
}

build_from_recipe() {
    local pkg="$1"
    local rpath
    rpath=$(recipe_path "$pkg") || err "recipe $pkg not found"
    
    # --- VERSION CHECK LOGIC (Skip build if same version) ---
    local recipe_ver="unknown"
    [ -f "$rpath/version" ] && recipe_ver=$(cat "$rpath/version")
    
    local installed_ver=$(get_installed_ver "$pkg")
    
    if [ "$installed_ver" != "none" ]; then
        if [ "$installed_ver" = "$recipe_ver" ]; then
            info "Package '$pkg' is already installed at version $installed_ver. Up to date."
            return 0
        else
            info "Upgrading '$pkg' from $installed_ver to $recipe_ver..."
        fi
    else
        info "Installing '$pkg' version $recipe_ver..."
    fi
    # -----------------------------------------------------

    # build environment
    local buildtmp="$TMPDIR/astral-build-$pkg-$$"
    mkdir -p "$buildtmp"

    if [ -d "$rpath" ]; then
        cp -a "$rpath"/* "$buildtmp"/
    else
        cp -a "$rpath" "$buildtmp/recipe.astral"
    fi
    cd "$buildtmp"

    if [ -f "./build" ]; then
        chmod +x ./build || true
        local PKGDIR="$buildtmp/pkg"
        mkdir -p "$PKGDIR"
        
        # ISOLATED BUILD (Using DESTDIR)
        ( cd "$buildtmp" && DESTDIR="$PKGDIR" ./build ) || err "build failed for $pkg"
        
        if [ -f "./package" ]; then
            ( cd "$buildtmp" && DESTDIR="$PKGDIR" PKGDIR="$PKGDIR" ./package ) || err "package() failed for $pkg"
        else
            err "no package() script found for $pkg"
        fi
        
        create_meta "$pkg" "$recipe_ver" "x86_64" "$PKGDIR"
        
        info "Installing $pkg files to root filesystem..."
        
        # Install to /
        tar -C "$PKGDIR" -cf - . | tar -C / -xf - || err "failed to extract package files"
        
        # Record database
        local files=$(tar -C "$PKGDIR" -tf . | grep -v '^\.$' | grep -v '^\.\/$' | grep -v '^\.astral-meta$' || true)
        local pkgdir="$DB_DIR/$pkg"
        mkdir -p "$pkgdir"
        printf '%s\n' "$recipe_ver" > "$pkgdir/version"
        printf '%s\n' "$files" > "$pkgdir/files"
        
        if [ -f "$buildtmp/depends" ]; then
            cp "$buildtmp/depends" "$pkgdir/depends"
        fi
        
        info "Successfully installed $pkg ($recipe_ver)."
        rm -rf "$buildtmp"
    else
        err "Recipe $pkg has no build script"
    fi
}

update_repo() {
    info "Updating package database index..."
    local INDEX_URL="${REPO_URL}astral.index"
    if curl -fsSL "$INDEX_URL" -o "$INDEX_FILE"; then
        info "Database updated successfully."
    else
        err "Failed to download index file from $INDEX_URL."
        return 1
    fi
}

search_pkg() {
    local query="$1"
    info "Searching for package '$query'..."
    info "--- Local Recipes ---"
    local found_local=0
    for r in "$RECIPES_DIR"/*; do
        if [ -d "$r" ]; then
            local pkg_name=$(basename "$r")
            if echo "$pkg_name" | grep -iq "$query"; then
                local ver="unknown"
                [ -f "$r/version" ] && ver=$(cat "$r/version")
                printf "L: %-20s (v%s)\n" "$pkg_name" "$ver"
                found_local=1
            fi
        fi
    done
    [ "$found_local" -eq 0 ] && info "No local recipes found."

    info "--- Remote Index ---"
    [ -f "$INDEX_FILE" ] || { info "Remote index not found. Run 'astral -u'."; return 0; }
    local found_remote=0
    while IFS= read -r line; do
        local pkg_name=$(echo "$line" | awk '{print $1}')
        local pkg_ver=$(echo "$line" | awk '{print $2}')
        if echo "$pkg_name" | grep -iq "$query"; then
            printf "R: %-20s (v%s)\n" "$pkg_name" "$pkg_ver"
            found_remote=1
        fi
    done < "$INDEX_FILE"
    [ "$found_remote" -eq 0 ] && info "No remote packages found."
}

self_update() {
    info "Starting astral self-update..."
    command -v curl >/dev/null 2>&1 || { err "curl not found."; return 1; }
    local tmp_file="$TMPDIR/astral-new.$$"
    if ! curl -fsSL "$SELF_UPDATE_URL" -o "$tmp_file"; then
        err "Failed to download new astral script."
        rm -f "$tmp_file"
        return 1
    fi
    if ! head -n 1 "$tmp_file" | grep -q '^#![[:space:]]*/bin/sh'; then
        err "Downloaded file invalid (missing shebang)."
        rm -f "$tmp_file"
        return 1
    fi
    chmod +x "$tmp_file"
    if mv -f "$tmp_file" "$SELF_UPDATE_PATH"; then
        info "Self-update successful!"
    else
        err "Failed to replace $SELF_UPDATE_PATH."
        rm -f "$tmp_file"
        return 1
    fi
}

remove_pkg() {
    pkg="$1"
    pkgdir="$DB_DIR/$pkg"
    [ -d "$pkgdir" ] || err "package $pkg not installed"
    info "Removing $pkg"
    local dirs_to_check=""
    while IFS= read -r f; do
        [ -z "$f" ] && continue
        case "$f" in
            bin|lib|sbin|usr|etc|bin/*|lib/*|sbin/*|usr/*|etc/*|/bin|/lib|/sbin|/usr|/etc|/bin/*|/lib/*|/sbin/*|/usr/*|/etc/*)
                continue ;;
        esac
        if [ -d "/$f" ]; then
            dirs_to_check="$f $dirs_to_check"
            continue
        fi
        if [ -e "/$f" ]; then rm -f "/$f"; fi
    done < "$pkgdir/files"
    
    for d in $dirs_to_check; do
        rmdir "/$d" 2>/dev/null || true
    done
    rm -rf "$pkgdir"
    info "Removed $pkg"
}

removedep_pkg() {
    pkg="$1"
    remove_pkg "$pkg"
    info "Scanning for orphaned dependencies..."
    while true; do
        found_orphan=0
        for dep_dir in "$DB_DIR"/*; do
            [ -d "$dep_dir" ] || continue
            dep_name=$(basename "$dep_dir")
            if ! is_pkg_required "$dep_name"; then
                info "Removing orphan dependency: $dep_name"
                remove_pkg "$dep_name"
                found_orphan=1
                break
            fi
        done
        [ "$found_orphan" -eq 0 ] && break
    done
}

list_installed() {
  for d in "$DB_DIR"/*; do
    [ -d "$d" ] || continue
    printf '%s %s\n' "$(basename "$d")" "$(cat "$d/version" 2>/dev/null || echo unknown)"
  done
}

# CLI dispatch
if [ $# -lt 1 ]; then usage; exit 1; fi

case "$1" in
  -s|--sync)
    [ $# -gt 1 ] || err "pkg required"
    sync_pkg_recursive "$2"
    ;;
  -comp|--compile)
    [ $# -gt 1 ] || err "pkg required"
    build_from_recipe "$2"
    ;;
  -u|--update)
    update_repo
    ;;
  --search)
    [ $# -gt 1 ] || err "package name required"
    search_pkg "$2"
    ;;
  -R|--Remove)
    [ $# -gt 1 ] || err "pkg required"
    remove_pkg "$2"
    ;;
  -r|--RemoveDep)
    [ $# -gt 1 ] || err "pkg required"
    removedep_pkg "$2"
    ;;
  -U|--self-update)
    self_update
    ;;
  -y|--All)
    info "Listing installed packages."
    list_installed
    ;;
  --inspect)
    [ $# -gt 1 ] || err "pkg required"
    r=$(recipe_path "$2") || err "recipe not found"
    if [ -d "$r" ]; then
      ls -la "$r"
      [ -f "$r/build" ] && sed -n '1,200p' "$r/build"
    else
      sed -n '1,200p' "$r"
    fi
    ;;
  --list-installed)
    list_installed
    ;;
  *)
    usage
    ;;
esac
